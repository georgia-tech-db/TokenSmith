[
    {
        "text": "Silberschatz\u2212Korth\u2212Sudarshan: Database System Concepts, Fourth Edition II. Relational Databases 4. SQL 149 \u00a9 The McGraw\u2212Hill Companies, 2001 4.2 Basic Structure 143 4.2.7 Ordering the Display of Tuples SQL offers the user some control over the order in which tuples in a relation are displayed. The order by clause causes the tuples in the result of a query to appear in sorted order. To list in alphabetic order all customers who have a loan at the Perryridge branch, we write select distinct customer-name from borrower, loan where borrower.loan-number = loan.loan-number and branch-name = \u2019Perryridge\u2019 order by customer-name By default, the order by clause lists items in ascending order. To specify the sort order, we may specify desc for descending order or asc for ascending order. Furthermore, ordering can be performed on multiple attributes. Suppose that we wish to list the entire loan relation in descending order of amount. If several loans have the same amount, we order them in ascending order by loan number. We express this query in SQL as follows: select * from loan order by amount desc, loan-number asc To ful\ufb01ll an order by request, SQL must perform a sort. Since sorting a large number of tuples may be costly, it should be done only when necessary.\n4.2.8 Duplicates Using relations with duplicates offers advantages in several situations. Accordingly, SQL formally de\ufb01nes not only what tuples are in the result of a query, but also how many copies of each of those tuples appear in the result. We can de\ufb01ne the duplicate semantics of an SQL query using multiset versions of the relational operators. Here, we de\ufb01ne the multiset versions of several of the relational-algebra operators. Given multiset relations r1 and r2, 1. If there are c1 copies of tuple t1 in r1, and t1 satis\ufb01es selection \u03c3\u03b8, then there are c1 copies of t1 in \u03c3\u03b8(r1).\n2. For each copy of tuple t1 in r1, there is a copy of tuple \u03a0A(t1) in \u03a0A(r1), where \u03a0A(t1) denotes the projection of the single tuple t1.\n3. If there are c1 copies of tuple t1 in r1 and c2 copies of tuple t2 in r2, there are c1 \u2217c2 copies of the tuple t1.t2 in r1 \u00d7 r2.\nFor example, suppose that relations r1 with schema (A, B) and r2 with schema (C) are the following multisets: r1 = {(1, a), (2, a)} r2 = {(2), (3), (3)} Silberschatz\u2212Korth\u2212Sudarshan: Database System Concepts, Fourth Edition II. Relational Databases 4. SQL 150 \u00a9 The McGraw\u2212Hill Companies, 2001 144 Chapter 4 SQL Then \u03a0B(r1) would be {(a), (a)}, whereas \u03a0B(r1) \u00d7 r2 would be {(a, 2), (a, 2), (a, 3), (a, 3), (a, 3), (a, 3)} We can now de\ufb01ne how many copies of each tuple occur in the result of an SQL query. An SQL query of the form select A1, A2, . . . , An from r1, r2, . . . , rm where P is equivalent to the relational-algebra expression \u03a0A1, A2,...,An(\u03c3P (r1 \u00d7 r2 \u00d7 \u00b7 \u00b7 \u00b7 \u00d7 rm)) using the multiset versions of the relational operators \u03c3, \u03a0, and \u00d7.\nSet Operations The SQL operations union, intersect, and except operate on relations and correspond to the relational-algebra operations \u222a, \u2229, and \u2212. Like union, intersection, and set difference in relational algebra, the relations participating in the operations must be compatible; that is, they must have the same set of attributes.\nLet us demonstrate how several of the example queries that we considered in Chapter 3 can be written in SQL. We shall now construct queries involving the union, intersect, and except operations of two sets: the set of all customers who have an account at the bank, which can be derived by select customer-name from depositor and the set of customers who have a loan at the bank, which can be derived by select customer-name from borrower We shall refer to the relations obtained as the result of the preceding queries as d and b, respectively.\n4.3.1 The Union Operation To \ufb01nd all customers having a loan, an account, or both at the bank, we write (select customer-name from depositor) union (select customer-name from borrower) Silberschatz\u2212Korth\u2212Sudarshan: Database System Concepts, Fourth Edition II. Relational Databases 4. SQL 151 \u00a9 The McGraw\u2212Hill Companies, 2001 4.3 Set Operations 145 The union operation automatically eliminates duplicates, unlike the select clause.\nThus, in the preceding query, if a customer\u2014say, Jones\u2014has several accounts or loans (or both) at the bank, then Jones will appear only once in the result.\nIf we want to retain all duplicates, we must write union all in place of union: (select customer-name from depositor) union all (select customer-name from borrower) The number of duplicate tuples in the result is equal to the total number of duplicates that appear in both d and b. Thus, if Jones has three accounts and two loans at the bank, then there will be \ufb01ve tuples with the name Jones in the result.\n4.3.2 The Intersect Operation To \ufb01nd all customers who have both a loan and an account at the bank, we write (select distinct customer-name from depositor) intersect (select distinct customer-name from borrower) The intersect operation automatically eliminates duplicates. Thus, in the preceding query, if a customer\u2014say, Jones\u2014has several accounts and loans at the bank, then Jones will appear only once in the result.\nIf we want to retain all duplicates, we must write intersect all in place of intersect: (select customer-name from depositor) intersect all (select customer-name from borrower) The number of duplicate tuples that appear in the result is equal to the minimum number of duplicates in both d and b. Thus, if Jones has three accounts and two loans at the bank, then there will be two tuples with the name Jones in the result.\n4.3.3 The Except Operation To \ufb01nd all customers who have an account but no loan at the bank, we write Silberschatz\u2212Korth\u2212Sudarshan: Database System Concepts, Fourth Edition II. Relational Databases 4. SQL 152 \u00a9 The McGraw\u2212Hill Companies, 2001 146 Chapter 4 SQL (select distinct customer-name from depositor) except (select customer-name from borrower) The except operation automatically eliminates duplicates. Thus, in the preceding query, a tuple with customer name Jones will appear (exactly once) in the result only if Jones has an account at the bank, but has no loan at the bank.\nIf we want to retain all duplicates, we must write except all in place of except: (select customer-name from depositor) except all (select customer-name from borrower) The number of duplicate copies of a tuple in the result is equal to the number of duplicate copies of the tuple in d minus the number of duplicate copies of the tuple in b, provided that the difference is positive. Thus, if Jones has three accounts and one loan at the bank, then there will be two tuples with the name Jones in the result.\nIf, instead, this customer has two accounts and three loans at the bank, there will be no tuple with the name Jones in the result.\nAggregate Functions Aggregate functions are functions that take a collection (a set or multiset) of values as input and return a single value. SQL offers \ufb01ve built-in aggregate functions: \u2022 Average: avg \u2022 Minimum: min \u2022 Maximum: max \u2022 Total: sum \u2022 Count: count The input to sum and avg must be a collection of numbers, but the other operators can operate on collections of nonnumeric data types, such as strings, as well.\nAs an illustration, consider the query \u201cFind the average account balance at the Perryridge branch.\u201d We write this query as follows: select avg (balance) from account where branch-name = \u2019Perryridge\u2019 Silberschatz\u2212Korth\u2212Sudarshan: Database System Concepts, Fourth Edition II. Relational Databases 4. SQL 153 \u00a9 The McGraw\u2212Hill Companies, 2001 4.4 Aggregate Functions 147 The result of this query is a relation with a single attribute, containing a single tuple with a numerical value corresponding to the average balance at the Perryridge branch. Optionally, we can give a name to the attribute of the result relation by using the as clause.\nThere are circumstances where we would like to apply the aggregate function not only to a single set of tuples, but also to a group of sets of tuples; we specify this wish in SQL using the group by clause. The attribute or attributes given in the group by clause are used to form groups. Tuples with the same value on all attributes in the group by clause are placed in one group.\nAs an illustration, consider the query \u201cFind the average account balance at each branch.\u201d We write this query as follows: select branch-name, avg (balance) from account group by branch-name Retaining duplicates is important in computing an average. Suppose that the account balances at the (small) Brighton branch are $1000, $3000, $2000, and $1000. The average balance is $7000/4 = $1750.00. If duplicates were eliminated, we would obtain the wrong answer ($6000/3 = $2000).\nThere are cases where we must eliminate duplicates before computing an aggregate function. If we do want to eliminate duplicates, we use the keyword distinct in the aggregate expression. An example arises in the query \u201cFind the number of depositors for each branch.\u201d In this case, a depositor counts only once, regardless of the number of accounts that depositor may have. We write this query as follows: select branch-name, count (distinct customer-name) from depositor, account where depositor.account-number = account.account-number group by branch-name At times, it is useful to state a condition that applies to groups rather than to tuples. For example, we might be interested in only those branches where the average account balance is more than $1200. This condition does not apply to a single tuple; rather, it applies to each group constructed by the group by clause. To express such a query, we use the having clause of SQL. SQL applies predicates in the having clause after groups have been formed, so aggregate functions may be used. We express this query in SQL as follows: select branch-name, avg (balance) from account group by branch-name having avg (balance) > 1200 At times, we wish to treat the entire relation as a single group. In such cases, we do not use a group by clause. Consider the query \u201cFind the average balance for all accounts.\u201d We write this query as follows:",
        "metadata": {
            "source_book": "Database System Concepts, Fourth Edition",
            "start_page": 141,
            "end_page": 145,
            "primary_topic": "II. Relational Databases",
            "sub_topic": "4. SQL",
            "chunk_number": 1
        }
    }
]