benchmarks:
  - id: "transactions"
    question: "How do atomicity, consistency, isolation, and durability (ACID) interact with concurrent access and failure recovery in a database system, and which components of the system architecture are responsible for enforcing these guarantees across client-server deployments?"
    expected_answer: "ACID properties ensure that each unit of work transforms a consistent database state to another, executes as if alone, and persists its effects despite failures, with atomicity and durability enforced via failure recovery and consistency maintained by application-defined constraints and transaction semantics. Concurrency control is required to avoid anomalies when multiple users access and update data simultaneously, while the transaction manager and concurrency-control mechanisms coordinate interaction among transactions to preserve correctness despite interleavings. The storage manager's transaction and buffer managers, together with the authorization/integrity manager, implement these guarantees at the physical layer, while the query processor translates high-level requests into efficient, correct execution plans that respect ACID. In two-tier and three-tier client-server architectures, the database server provides ACID semantics across remote connections, while application servers encapsulate business logic and delegate transactional data access to the database through standardized interfaces."
    keywords: ["ACID", "concurrent", "consistent", "transaction", "server"]
    similarity_threshold: 0.7
    golden_chunks: null  # Optional: list of most relevant chunk texts for this question
    
  - id: "er_modeling"
    question: "When translating an E-R schema to the relational model, how do mapping cardinalities, keys, multivalued and composite attributes, and weak entity sets influence schema choices, and what trade-offs arise when deciding whether to use relationship sets versus entity sets?"
    expected_answer: "Mapping cardinalities determine how relationship keys are formed: many-to-many relationships use the union of participating primary keys as the relationship's primary key, whereas in many-to-one and one-to-one cases a single side's key may suffice, affecting how foreign keys are represented in the relational schema. Composite attributes are decomposed into their components as separate columns, while multivalued attributes are mapped to separate tables that include a column for the owning entity's primary key plus a column for the multivalued attribute, preventing redundancy and supporting variable cardinalities. Weak entity sets require inclusion of the identifying strong entity's primary key plus the discriminator as the weak entity's primary key, and identifying relationships need not be materialized as separate tables since their keys are embedded in the weak entity table. Choosing an entity set versus a relationship set hinges on whether additional properties or multiple associations must be represented; misplacing attributes into entities or relationships can cause redundancy or update anomalies, so the design should favor explicit relationships when expressing actions or many-to-many associations and entities when modeling objects with their own identity and attributes."
    keywords: ["retrieval", "generation", "external knowledge", "information", "accurate"]
    similarity_threshold: 0.7
    golden_chunks: null
    
  - id: "relational_algebra"
    question: "Relational algebra defines selection, projection, joins, and division on sets, but SQL permits duplicates, nulls, and three-valued logic; how do these differences affect query semantics, especially joins, aggregates, and set operations across algebra and SQL?"
    expected_answer: "Relational algebra's operations are set-based with duplicate elimination by definition, whereas SQL retains duplicates by default and requires DISTINCT to remove them, which changes the cardinality and performance characteristics of projections, unions, intersections, and differences relative to their pure algebra counterparts. Nulls in SQL propagate through arithmetic, yield unknown on comparisons, and are handled via three-valued logic in WHERE, HAVING, and join predicates; aggregates ignore nulls (except COUNT(*)), and outer joins introduce nulls explicitly to retain unmatched tuples, all of which differ from classical algebra that assumes atomic values and two-valued logic. SQL's set operations (UNION/INTERSECT/EXCEPT and their ALL variants) define duplicate semantics explicitly, while EXISTS/IN/SOME/ALL bridge calculus-style subqueries with multiset behavior, and natural/outer joins extend algebra with convenient syntax and null-padding to control tuple preservation."
    keywords: ["neural networks", "layers", "patterns", "features", "data"]
    similarity_threshold: 0.65
    golden_chunks: null

  - id: "materialization"
    question: "What are the purposes and semantics of views in SQL and the relational model, how do materialized views differ from virtual views, and why are updates through views restricted or anomalous in some cases?"
    expected_answer: "Views provide virtual relations defined by stored queries that simplify access paths, hide sensitive attributes, and present integrated abstractions; systems usually store the definition and expand it at query time, making view contents reflect base relations dynamically. Materialized views persist view results physically for performance and must be kept consistent with base tables through view maintenance, trading storage and maintenance overhead for faster query response on frequently used derived data. Updates through views can be ambiguous or non-translatable—especially when views span multiple base relations or omit key columns—so many systems restrict modifications to views defined over a single base table with straightforward attribute mappings, otherwise requiring null padding or causing anomalies that do not achieve the intended base updates."
    keywords: ["indexing", "chunks", "embeddings", "vector", "database", "searchable"]
    similarity_threshold: 0.6
    golden_chunks: null

  - id: "architectures"
    question: "How do two-tier and three-tier architectures structure database applications, and how do embedded SQL, dynamic SQL, ODBC, and JDBC enable host-language programs to issue queries and updates while respecting transactional boundaries?"
    expected_answer: "In a two-tier architecture, client applications issue SQL directly to a database server over a network connection, whereas three-tier designs interpose an application server that encapsulates business logic and communicates with the database on behalf of thin clients, improving scalability and control over shared logic and data access. Embedded SQL lets host-language programs declare cursors, bind variables, fetch tuples, and execute updates with a preprocessor translating SQL into host-language calls, while dynamic SQL constructs statements at runtime for flexible interactions, and both modes participate in transactions demarcated by commit/rollback or atomic blocks. Standard APIs like ODBC (for C) and JDBC (for Java) provide portable connection management, prepared statements, parameter binding, result-set iteration, and explicit transaction control, decoupling application code from specific database protocols while leveraging the server's transaction manager for ACID across sessions."
    keywords: []
    similarity_threshold: 0.7
    golden_chunks: null
