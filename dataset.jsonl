{"question": "List four significant differences between a file-processing system and a DBMS.", "gold_text": "1.2 Database Systems versus File Systems Consider part of a savings-bank enterprise that keeps information about all cus- tomers and savings accounts. One way to keep the information on a computer is to store it in operating system files. To allow users to manipulate the information, the system has a number of application programs that manipulate the files, including • A program to debit or credit an account • A program to add a new account • A program to find the balance of an account • A program to generate monthly statements System programmers wrote these application programs to meet the needs of the bank. New application programs are added to the system as the need arises. For exam- ple, suppose that the savings bank decides to offer checking accounts. As a result, the bank creates new permanent files that contain information about all the checking accounts maintained in the bank, and it may have to write new application programs to deal with situations that do not arise in savings accounts, such as overdrafts. Thus, as time goes by, the system acquires more files and more application programs. This typical file-processing system is supported by a conventional operating sys- tem. The system stores permanent records in various files, and it needs different application programs to extract records from, and add records to, the appropriate files. Before database management systems (DBMSs) came along, organizations usu- ally stored information in such systems. Keeping organizational information in a file-processing system has a number of major disadvantages: • Data redundancy and inconsistency. Since different programmers create the files and application programs over a long period, the various files are likely to have different formats and the programs may be written in several pro- gramming languages. Moreover, the same information may be duplicated in several places (files). For example, the address and telephone number of a par- ticular customer may appear in a file that consists of savings-account records and in a file that consists of checking-account records. This redundancy leads to higher storage and access cost. In addition, it may lead to data inconsis- tency; that is, the various copies of the same data may no longer agree. For example, a changed customer address may be reflected in savings-account records but not elsewhere in the system. • Difficulty in accessing data. Suppose that one of the bank officers needs to find out the names of all customers who live within a particular postal-code area. The officer asks the data-processing department to generate such a list. Because the designers of the original system did not anticipate this request, there is no application program on hand to meet it. There is, however, an ap- plication program to generate the list of all customers. The bank officer hasnow two choices: either obtain the list of all customers and extract the needed information manually or ask a system programmer to write the necessary application program. Both alternatives are obviously unsatisfactory. Suppose that such a program is written, and that, several days later, the same officer needs to trim that list to include only those customers who have an account balance of $10,000 or more. As expected, a program to generate such a list does not exist. Again, the officer has the preceding two options, neither of which is satisfactory. The point here is that conventional file-processing environments do not al- low needed data to be retrieved in a convenient and efficient manner. More responsive data-retrieval systems are required for general use. • Data isolation. Because data are scattered in various files, and files may be in different formats, writing new application programs to retrieve the appropri- ate data is difficult. • Integrity problems. The data values stored in the database must satisfy cer- tain types of consistency constraints. For example, the balance of a bank ac- count may never fall below a prescribed amount (say, $25). Developers enforce these constraints in the system by adding appropriate code in the various ap- plication programs. However, when new constraints are added, it is difficult to change the programs to enforce them. The problem is compounded when constraints involve several data items from different files. • Atomicity problems. A computer system, like any other mechanical or elec- trical device, is subject to failure. In many applications, it is crucial that, if a failure occurs, the data be restored to the consistent state that existed prior to the failure. Consider a program to transfer $50 from account A to account B. If a system failure occurs during the execution of the program, it is possible that the $50 was removed from account A but was not credited to account B, resulting in an inconsistent database state. Clearly, it is essential to database consistency that either both the credit and debit occur, or that neither occur. That is, the funds transfer must be atomic—it must happen in its entirety or not at all. It is difficult to ensure atomicity in a conventional file-processing system. • Concurrent-access anomalies. For the sake of overall performance of the sys- tem and faster response, many systems allow multiple users to update the data simultaneously. In such an environment, interaction of concurrent up- dates may result in inconsistent data. Consider bank account A, containing $500. If two customers withdraw funds (say $50 and $100 respectively) from account A at about the same time, the result of the concurrent executions may leave the account in an incorrect (or inconsistent) state. Suppose that the pro- grams executing on behalf of each withdrawal read the old balance, reduce that value by the amount being withdrawn, and write the result back. If the two programs run concurrently, they may both read the value $500, and write back $450 and $400, respectively. Depending on which one writes the valuelast, the account may contain either $450 or $400, rather than the correct value of $350. To guard against this possibility, the system must maintain some form of supervision. But supervision is difficult to provide because data may be accessed by many different application programs that have not been coordi- nated previously. • Security problems. Not every user of the database system should be able to access all the data. For example, in a banking system, payroll personnel need to see only that part of the database that has information about the various bank employees. They do not need access to information about customer ac- counts. But, since application programs are added to the system in an ad hoc manner, enforcing such security constraints is difficult. These difficulties, among others, prompted the development of database systems. In what follows, we shall see the concepts and algorithms that enable database sys- tems to solve the problems with file-processing systems. In most of this book, we use a bank enterprise as a running example of a typical data-processing application found in a corporation."}
{"question": "What are the components of a query processor?", "gold_text": "The query processor components include • DDL interpreter, which interprets DDL statements and records the definitions in the data dictionary. • DML compiler, which translates DML statements in a query language into an evaluation plan consisting of low-level instructions that the query evaluation engine understands. A query can usually be translated into any of a number of alternative eval- uation plans that all give the same result. The DML compiler also performs query optimization, that is, it picks the lowest cost evaluation plan from amo- ng the alternatives. • Query evaluation engine, which executes low-level instructions generated by the DML compiler."}
{"question": "Define the concept of aggregation. Give two examples where this concept is useful.", "gold_text": "2.7.5 Aggregation One limitation of the E-R model is that it cannot express relationships among rela- tionships. To illustrate the need for such a construct, consider the ternary relationship works-on, which we saw earlier, between a employee, branch, and job (see Figure 2.13). Now, suppose we want to record managers for tasks performed by an employee at a branch; that is, we want to record managers for (employee, branch, job) combinations. Let us assume that there is an entity set manager. One alternative for representing this relationship is to create a quaternary relation- ship manages between employee, branch, job, and manager. (A quaternary relationship is required—a binary relationship between manager and employee would not permit us to represent which (branch, job) combinations of an employee are managed by which manager.) Using the basic E-R modeling constructs, we obtain the E-R diagram of Figure 2.18. (We have omitted the attributes of the entity sets, for simplicity.) It appears that the relationship sets works-on and manages can be combined into one single relationship set. Nevertheless, we should not combine them into a single relationship, since some employee, branch, job combinations many not have a manager. There is redundant information in the resultant figure, however, since every em- ployee, branch, job combination in manages is also in works-on. If the manager were a value rather than an manager entity, we could instead make manager a multivalued at- tribute of the relationship works-on. But doing so makes it more difficult (logically as well as in execution cost) to find, for example, employee-branch-job triples for which a manager is responsible. Since the manager is a manager entity, this alternative is ruled out in any case. The best way to model a situation such as the one just described is to use aggrega- tion. Aggregation is an abstraction through which relationships are treated as higher- level entities. Thus, for our example, we regard the relationship set works-on (relating the entity sets employee, branch, and job) as a higher-level entity set called works-on. Such an entity set is treated in the same manner as is any other entity set. We can then create a binary relationship manages between works-on and manager to represent who manages what tasks. Figure 2.19 shows a notation for aggregation commonly used to represent the above situation."}
{"question": "A weak entity set can always be made into a strong entity set by adding to its attributes the primary key attributes of its identifying entity set. Outline what sort of redundancy will result if we do so.", "gold_text": "2.9.3.1 Redundancy of Tables A relationship set linking a weak entity set to the corresponding strong entity set is treated specially. As we noted in Section 2.6, these relationships are many-to-one and have no descriptive attributes. Furthermore, the primary key of a weak entity set in- cludes the primary key of the strong entity set. In the E-R diagram of Figure 2.16, the weak entity set payment is dependent on the strong entity set loan via the relation- ship set loan-payment. The primary key of payment is {loan-number, payment-number}, and the primary key of loan is {loan-number}. Since loan-payment has no descriptive attributes, the loan-payment table would have two columns, loan-number and payment- number. The table for the entity set payment has four columns, loan-number, payment- number, payment-date, and payment-amount. Every (loan-number, payment-number) com- bination in loan-payment would also be present in the payment table, and vice versa. Thus, the loan-payment table is redundant. In general, the table for the relationship set linking a weak entity set to its corresponding strong entity set is redundant and does not need to be present in a tabular representation of an E-R diagram."}
{"question": "Describe the circumstances in which you would choose to use embedded SQL rather than SQL alone or only a general-purpose programming language.", "gold_text": "4.12 Embedded SQL SQL provides a powerful declarative query language. Writing queries in SQL is usu- ally much easier than coding the same queries in a general-purpose programming language. However, a programmer must have access to a database from a general- purpose programming language for at least two reasons: 1. Not all queries can be expressed in SQL, since SQL does not provide the full expressive power of a general-purpose language. That is, there exist queries that can be expressed in a language such as C, Java, or Cobol that cannot be expressed in SQL. To write such queries, we can embed SQL within a more powerful language. SQL is designed so that queries written in it can be optimized automatically and executed efficiently—and providing the full power of a programming language makes automatic optimization exceedingly difficult. 2. Nondeclarative actions—such as printing a report, interacting with a user, or sending the results of a query to a graphical user interface—cannot be done from within SQL. Applications usually have several components, and query- ing or updating data is only one component; other components are written in general-purpose programming languages. For an integrated application, the programs written in the programming language must be able to access the database. The SQL standard defines embeddings of SQL in a variety of programming lan- guages, such as C, Cobol, Pascal, Java, PL/I, and Fortran. A language in which SQL queries are embedded is referred to as a host language, and the SQL structures per- mitted in the host language constitute embedded SQL. Programs written in the host language can use the embedded SQL syntax to ac- cess and update data stored in a database. This embedded form of SQL extends the programmer’s ability to manipulate the database even further. In embedded SQL, all query processing is performed by the database system, which then makes the result of the query available to the program one tuple (record) at a time. An embedded SQL program must be processed by a special preprocessor prior to compilation. The preprocessor replaces embedded SQL requests with host-language declarations and procedure calls that allow run-time execution of the database ac- cesses. Then, the resulting program is compiled by the host-language compiler. To identify embedded SQL requests to the preprocessor, we use the EXEC SQL statement; it has the form EXEC SQL <embedded SQL statement > END-EXEC The exact syntax for embedded SQL requests depends on the language in which SQL is embedded. For instance, a semicolon is used instead of END-EXEC when SQL is embedded in C. The Java embedding of SQL (called SQLJ) uses the syntax # SQL { <embedded SQL statement > }; We place the statement SQL INCLUDE in the program to identify the place where the preprocessor should insert the special variables used for communication between the program and the database system. Variables of the host language can be used within embedded SQL statements, but they must be preceded by a colon (:) to distin- guish them from SQL variables. Embedded SQL statements are similar in form to the SQL statements that we de- scribed in this chapter. There are, however, several important differences, as we note here. To write a relational query, we use the declare cursor statement. The result of the query is not yet computed. Rather, the program must use the open and fetch com- mands (discussed later in this section) to obtain the result tuples. Consider the banking schema that we have used in this chapter. Assume that we have a host-language variable amount, and that we wish to find the names and cities of residence of customers who have more than amount dollars in any account. We can write this query as follows: EXEC SQL declare c cursor for select customer-name, customer-city from depositor, customer, account where depositor.customer-name= customer.customer-name and account.account-number= depositor.account-number and account.balance > :amount END-EXEC The variable c in the preceding expression is called a cursor for the query. We use this variable to identify the query in the open statement, which causes the query to be evaluated, and in the fetch statement, which causes the values of one tuple to be placed in host-language variables. The open statement for our sample query is as follows: EXEC SQL open c END-EXEC This statement causes the database system to execute the query and to save the results within a temporary relation. The query has a host-language variable (:amount); the query uses the value of the variable at the time the open statement was executed. If the SQL query results in an error, the database system stores an error diagnostic in the SQL communication-area (SQLCA) variables, whose declarations are inserted by the SQL INCLUDE statement. An embedded SQL program executes a series of fetch statements to retrieve tuples of the result. The fetch statement requires one host-language variable for each at- tribute of the result relation. For our example query, we need one variable to hold the customer-name value and another to hold the customer-city value. Suppose that those variables are cn and cc, respectively. Then the statement: EXEC SQL fetch c into :cn, :cc END-EXEC produces a tuple of the result relation. The program can then manipulate the vari- ables cn and cc by using the features of the host programming language. A single fetch request returns only one tuple. To obtain all tuples of the result, the program must contain a loop to iterate over all tuples. Embedded SQL assists the programmer in managing this iteration. Although a relation is conceptually a set, the tuples of the result of a query are in some fixed physical order. When the program executes an open statement on a cursor, the cursor is set to point to the first tuple of the result. Each time it executes a fetch statement, the cursor is updated to point to the next tuple of the result. When no further tuples remain to be processed, the variable SQLSTATE in the SQLCA is set to ’02000’ (meaning“no data”). Thus, we can use a while loop (or equivalent loop) to process each tuple of the result. We must use the close statement to tell the database system to delete the tempo- rary relation that held the result of the query. For our example, this statement takes the form EXEC SQL close c END-EXEC SQLJ, the Java embedding of SQL, provides a variation of the above scheme, where Java iterators are used in place of cursors. SQLJ associates the results of a query with an iterator, and the next() method of the Java iterator interface can be used to step through the result tuples, just as the preceding examples use fetch on the cursor. Embedded SQL expressions for database modification (update, insert, and delete) do not return a result. Thus, they are somewhat simpler to express. A database- modification request takes the form EXEC SQL < any valid update, insert, or delete> END-EXEC Host-language variables, preceded by a colon, may appear in the SQL database- modification expression. If an error condition arises in the execution of the statement, a diagnostic is set in the SQLCA. Database relations can also be updated through cursors. For example, if we want to add 100 to the balance attribute of every account where the branch name is“Per- ryridge”, we could declare a cursor as follows. declare c cursor for select * from account where branch-name = ‘Perryridge‘ for update We then iterate through the tuples by performing fetch operations on the cursor (as illustrated earlier), and after fetching each tuple we execute the following code update account set balance= balance + 100 where current of c Embedded SQL allows a host-language program to access the database, but it pro- vides no assistance in presenting results to the user or in generating reports. Most commercial database products include tools to assist application programmers in creating user interfaces and formatted reports. "}