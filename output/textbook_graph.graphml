<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd"><key id="d3" for="edge" attr.name="label" attr.type="string"/>
<key id="d2" for="node" attr.name="community" attr.type="long"/>
<key id="d1" for="node" attr.name="chunk_ids" attr.type="string"/>
<key id="d0" for="graph" attr.name="community_summaries" attr.type="string"/>
<graph edgedefault="undirected"><data key="d0">{"4": "Here is a concise summary of the text, focusing on the key concepts:\n\nThe chapter introduces database systems, which are designed to manage large amounts of data efficiently. It discusses the importance of databases in modern computing, including their role in facilitating interactions between users and computer systems.\n\nThe chapter then describes the different levels of abstraction in database design: physical, logical, and view levels. The physical level involves managing storage and retrieval of data, while the logical level focuses on defining relationships between data entities. The view level provides a high-level perspective, allowing users to interact with the system without worrying about the underlying details.\n\nThe chapter also introduces three types of database users:\n\n1. Naive users: unsophisticated users who interact with the system through pre-written application programs or forms interfaces.\n2. Application programmers: computer professionals who write custom applications that interact with the database.\n3. Database administrators (DBAs): experts who manage and maintain the database, including designing schema, storage structures, and access methods.\n\nThe chapter also covers data models, including the entity-relationship model, relational model, object-oriented model, and semi-structured model. It highlights the importance of data consistency constraints and views in ensuring data integrity.\n\nOverall, the chapter provides a comprehensive overview of the fundamental concepts and components of database systems, setting the stage for more advanced topics to be covered in subsequent chapters.", "2": "Here is a concise summary of the text, focusing on key concepts:\n\n**Database Systems**\n\nA database system (DBMS) is a software system that allows users to interact with data stored in a centralized repository. The DBMS manages data storage and retrieval, providing features such as data integrity, security, and concurrency control.\n\n**Key Concepts**\n\n1. **Data Models**: Database systems use various data models, including relational, hierarchical, network, and object-oriented models.\n2. **Schemas**: A database schema is the overall design of the database, while an instance represents the current state of the database.\n3. **Transactions**: Transactions are units of work that perform a single logical function in a database application. They must be atomic (all-or-nothing), consistent, and durable (persist despite system failure).\n4. **Concurrent Access**: Many systems allow multiple users to access the database simultaneously, which can lead to concurrency control issues.\n5. **Users and Administrators**: Users include naive users, specialized users, and application programmers. Database administrators (DBAs) are responsible for managing and maintaining the database.\n\n**Relational Model**\n\nThe relational model is a popular data model used in many DBMSs. It organizes data into tables with rows and columns, where each row represents a record, and each column represents a field or attribute.\n\nI hope this summary helps! Let me know if you have any further questions.", "10": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses database systems and their importance in modern organizations. It highlights various applications of databases, including banking, airlines, universities, credit card transactions, and telecommunications. A primary goal of a database system is to provide users with an abstract view of the data, hiding certain implementation details.\n\nThe text also explains the concept of data models, which describe how data are stored and manipulated. The relational model is widely used, providing a convenient graphical representation to view data, relationships, and constraints. Other data models include the entity-relationship (E-R) model, object-oriented model, and semistructured data models.\n\nThe overall design of a database is called the database schema, which is specified by a set of definitions expressed using a data definition language (DDL). The text also discusses storage management, query processing, and the importance of minimizing data movement between disk storage and main memory.\n\nFinally, the text touches on the concept of instances and schemas in databases. A database instance represents the collection of information stored at a particular moment, while a schema represents the overall design of the database. This analogy is useful for understanding how databases can change over time as information is inserted or deleted.\n\nOverall, the text emphasizes the importance of database systems in modern organizations and provides an overview of key concepts and terminology in the field.", "89": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs to access those data, designed to store and retrieve information efficiently and conveniently. The primary goal of a DBMS is to provide a way to manage large amounts of information while ensuring its safety, avoiding anomalies, and allowing for sharing among multiple users. This book focuses on the concepts and techniques developed by computer scientists to manage data, introducing the principles of database systems in this chapter.", "1": "Here is a concise summary of the text, focusing on the key concepts:\n\n**What is a Database Management System (DBMS)?**\nA DBMS is a software system that allows users to define, organize, and manage data in a database.\n\n**Key Concepts:**\n\n1. **Data Abstraction**: The idea of representing complex data structures as simpler, more abstract representations.\n2. **Database Schema**: A design or organization of the data stored in a database, including relationships between different pieces of data.\n3. **Database Instance**: A specific version of the database at a particular point in time.\n4. **Consistency Constraints**: Rules that ensure the integrity and accuracy of the data in the database (e.g., ensuring a bank account balance never falls below a certain threshold).\n5. **Data Views**: Different ways of looking at or accessing the same underlying data, often with varying levels of security and access control.\n\n**Challenges:**\n\n1. **Inconsistency Problems**: Dealing with redundant data storage and potential inconsistencies between different copies of the same data.\n2. **Difficulty in Accessing Data**: Writing new application programs to retrieve specific data when it is scattered across multiple files.\n3. **Integrity Problems**: Ensuring that data values satisfy certain consistency constraints.\n\n**DBMS Architecture:**\n\n1. **Physical Level**: The lowest level, where data is stored on disk or other storage devices.\n2. **Logical Level**: Where the database schema and relationships are defined, and where application programs interact with the database.\n3. **View Level**: Where users see different views of the same underlying data, often with varying levels of security and access control.\n\n**Database Languages:**\n\n1. **Data Definition Language (DDL)**: Used to define the structure of the database.\n2. **Data Manipulation Language (DML)**: Used to insert, update, or delete data in the database.\n3. **Query Language**: Used to retrieve specific data from the database.\n\nI hope this summary helps! Let me know if you have any further questions.", "90": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs that access those data, designed to store and retrieve information efficiently and conveniently. The primary goal is to manage large bodies of information while ensuring its safety and integrity, despite potential system failures or unauthorized access. To achieve this, DBMS must define structures for storing information, provide mechanisms for manipulating it, and prevent anomalous results when multiple users share the data. This book focuses on the concepts and techniques developed by computer scientists to manage data, with this chapter introducing the fundamental principles of database systems.", "91": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs to access those data, aiming to provide a convenient and efficient way to store and retrieve information relevant to an enterprise. The primary goal of a DBMS is to manage large bodies of information, defining structures for storage and providing mechanisms for manipulation, while ensuring the safety and integrity of the data. This chapter introduces the principles of database systems, highlighting the importance of managing data in modern organizations.", "92": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs to access that data, designed to store and retrieve information efficiently and conveniently. The primary goal of a DBMS is to manage large bodies of information, defining structures for storage and providing mechanisms for manipulation while ensuring data safety and avoiding anomalous results. This chapter introduces the fundamental principles of database systems, which will be further explored throughout this book.", "93": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs to access that data, aiming to provide efficient and convenient storage and retrieval of information relevant to an enterprise. The primary goal is to manage large amounts of data, involving defining structures for storage and manipulation, while ensuring safety from system crashes and unauthorized access. The DBMS must also prevent anomalous results when multiple users access the same information. This book focuses on the concepts and techniques developed by computer scientists to manage data, starting with a brief introduction to the principles of database systems in this chapter.", "94": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs to access that data, with the primary goal of providing efficient storage and retrieval of information. The DBMS manages large bodies of data by defining structures for storing information and mechanisms for manipulating it, while also ensuring data safety from system crashes or unauthorized access. Additionally, the system must avoid anomalous results when sharing data among multiple users. This book focuses on the concepts and techniques developed by computer scientists to manage data, with this chapter introducing the fundamental principles of database systems.", "95": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs that allow for convenient and efficient storage and retrieval of information relevant to an enterprise. The primary goal of a DBMS is to manage large bodies of information, defining structures for storage and providing mechanisms for manipulation while ensuring data safety from system crashes or unauthorized access. Additionally, the system must prevent anomalous results when sharing data among multiple users. This book focuses on the concepts and techniques developed by computer scientists for managing data, with this chapter introducing the principles of database systems.", "96": "Here is a concise summary of the text:\n\nA Database Management System (DBMS) is a collection of interrelated data and programs that access those data, designed to store and retrieve information efficiently. The primary goal is to provide a convenient way to manage large bodies of information while ensuring safety from crashes or unauthorized access. To achieve this, DBMSes must define structures for storing information, provide mechanisms for manipulating it, and prevent anomalous results when shared among multiple users. This book focuses on the concepts and techniques developed by computer scientists to manage data effectively.", "42": "Here is a concise summary of the text:\n\nThis chapter introduces the principles of database systems, highlighting their widespread applications across various industries. These applications include banking (customer info, accounts, loans, and transactions), airlines (reservations, schedules, and global access through phone lines and data networks), universities (student information, course registrations, and grades), credit card transactions (purchases, monthly statements, and account management), telecommunications (call records, billing, prepaid calling cards, and network information), and finance (holdings, sales, purchases of financial instruments). The chapter provides a brief overview of the importance and ubiquity of database systems in these organizations.", "97": "Here is a concise summary of the text:\n\nThe chapter introduces the principles of database systems, highlighting their widespread applications across various industries. Examples of organizations using databases include banking institutions for customer information and transactions, airlines for reservations and schedule management, universities for student records and course registration, credit card companies for transaction tracking, telecommunications providers for call records and billing, and financial institutions for instrument holdings and trading data. The chapter emphasizes the importance of database systems in managing information effectively, showcasing their versatility and relevance across multiple sectors.", "98": "Here is a concise summary of the text:\n\nThis chapter introduces the fundamental principles of database systems, highlighting their widespread use in various organizations. Examples of applications include banking (customer information, accounts, transactions), airlines (reservations, schedule information), universities (student info, course registrations, grades), credit card transactions, telecommunications, and finance (holding, sales, purchase records). These examples demonstrate how databases are used to manage critical data, with some organizations even using geographically distributed systems.", "99": "Here is a concise summary of the text:\n\nThis chapter introduces the principles of database systems, highlighting their importance in various organizations. Database applications are discussed across multiple industries, including banking (customer info, transactions), airlines (reservations, schedules), universities (student info, grades), credit card transactions, telecommunications, and finance (holdings, sales). These examples illustrate how databases enable efficient management and sharing of information within these organizations, with some early adopters like airlines using geographically distributed databases.", "100": "Here is a concise summary of the text:\n\nThis chapter introduces the principles of database systems, highlighting their widespread applications across various organizations. Database systems are crucial in industries such as banking (customer info, transactions), airlines (reservations, schedule management), universities (student records, course registration), credit card companies (transactions, monthly statements), telecommunications (calls, billing), and finance (instrument holdings, sales, purchases). These examples demonstrate the importance of databases in managing data efficiently and effectively.", "101": "Here is a concise summary of the text:\n\nThis chapter introduces the principles of database systems, highlighting their widespread use in various organizations. Database systems are essential for managing data in applications such as banking, airlines, universities, credit card transactions, telecommunications, and finance. These databases enable efficient storage, retrieval, and sharing of information across geographically distributed locations, as seen in the early adoption by airlines. The importance of database management is emphasized, setting the stage for exploring the concepts and techniques that computer scientists have developed to manage data effectively.", "0": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses the importance of databases in various enterprises, including telecommunications, finance, sales, manufacturing, and human resources. It highlights how databases are essential for storing and retrieving information efficiently.\n\nThe article then introduces two data models: the Entity-Relationship (E-R) model and the Relational model. The E-R model represents real-world entities and relationships among them using rectangles, ellipses, and diamonds in an E-R diagram. This model is widely used in database design to ensure integrity and consistency constraints.\n\nThe Relational model uses a collection of tables to represent data and relationships among them. Each table has multiple columns with unique names. The article presents a sample relational database comprising three tables: customer, account, and depositor, which shows the relationships between customers, accounts, and deposits.\n\nKey concepts and connections:\n\n* Databases are essential for storing and retrieving information efficiently in various enterprises.\n* The E-R model represents real-world entities and relationships among them using an E-R diagram.\n* The Relational model uses a collection of tables to represent data and relationships among them.\n* Both models are used in database design to ensure integrity and consistency constraints.\n* The E-R model is widely used in database design, and the Relational model is the most widely used data model.\n\nOverall, the text provides an introduction to databases, highlighting their importance and the two main data models used in database design: the Entity-Relationship model and the Relational model.", "22": "Here is a concise summary of the text:\n\nDatabases are essential tools in modern enterprises, serving various purposes such as record-keeping, billing, and inventory management across industries like telecommunication, finance, sales, manufacturing, and human resources. Over the past four decades, the use of databases has grown significantly, with early interactions being indirect through printed reports or agents. However, advancements in technology have enabled users to interact directly with databases via automated systems such as ATMs, interactive voice response systems, and computer interfaces, increasing accessibility and efficiency.", "31": "Here's a concise summary of the text:\n\nDatabases play a crucial role in various industries, such as telecommunication, finance, sales, manufacturing, and human resources. They store information on calls, financial instruments, customers, products, orders, employees, and more. Over the past four decades, the use of databases has grown significantly, with users initially interacting indirectly through printed reports or agents, then directly through automated systems like ATMs and phone interfaces. The concept of database schemas and instances can be understood as a program written in a programming language, where each variable has a particular value at a given instant. Database systems have multiple schemas, including physical, logical, and view levels, which enable users to access information online. Examples include accessing an online bookstore or bank website, which retrieve data from databases, or using the internet to interact with databases directly.", "102": "Here's a concise summary of the text:\n\nThe evolution of user interaction with databases has shifted from indirect access through agents or phone interfaces to direct access through automated teller machines and internet-based interfaces. With the rise of the internet, organizations converted their phone interfaces to web interfaces, making various services and information available online. As a result, users can now directly interact with databases when accessing online bookstores, banks, and other websites. This direct interaction enables users to store and retrieve data, such as order histories or personal preferences, which are stored in databases. The text highlights how the internet has enabled users to access and manipulate data stored in databases, changing the way we interact with information.", "103": "Here's a concise summary of the text:\n\nThe development of technology has enabled users to interact directly with databases through various interfaces, starting from human agents and automated teller machines. Phone-based interactive voice response systems allowed callers to access databases by pressing phone keys. The internet revolution in the late 1990s further increased direct user access to databases, as organizations converted their phone interfaces to web-based ones. Today, users can access a wide range of services and information online, including browsing products, placing orders, checking bank balances, and receiving targeted advertisements. These interactions involve storing and retrieving data from databases, demonstrating the growing importance of database technology in modern life.", "32": "Here is a concise summary of the text:\n\nThe development of databases has enabled users to interact with them directly through various interfaces, including automated teller machines and interactive voice response systems. The internet revolution further increased direct user access to databases, as organizations converted their phone-based interfaces to web-based ones. Today, we can access various services and information online, such as browsing book collections, checking bank balances, or receiving targeted advertisements based on our web behavior. This has led to a proliferation of data storage in databases, which are used to store user interactions, order information, and personal preferences, among other things.", "104": "Here's a concise summary of the text:\n\nThe evolution of user-database interaction began with intermediaries like bank tellers and airline reservation agents. Automated Teller Machines (ATMs) and Interactive Voice Response systems allowed users to interact directly with databases through phone interfaces. The Internet revolution in the late 1990s further enabled direct access, as organizations converted phone interfaces to web-based databases. Today, online services and information are readily accessible, such as browsing book collections or accessing bank accounts. As a result, user data is often stored in databases, used for tasks like personalized advertising and tracking website activity.", "43": "Here is a concise summary of the text:\n\nThe ability for users to interact with databases has evolved over time through various interfaces. Initially, people relied on intermediaries such as bank tellers and airline reservation agents, followed by automated teller machines (ATMs) and phone-based interactive voice response systems. The internet revolution in the late 1990s enabled direct user access to databases, leading to the widespread conversion of phone interfaces to web-based ones. Today, many services and information are available online, with users accessing databases through websites for tasks like browsing products, placing orders, retrieving financial information, or viewing personalized advertisements.", "3": "Here is a concise summary of the text, focusing on key concepts:\n\n**Database Systems**\n\n* A database system (DBMS) manages and organizes data to support various applications.\n* The DBMS provides a way to define, store, and manipulate data in a structured manner.\n\n**Key Concepts**\n\n1. **Data Models**: Two primary data models are discussed: Entity-Relationship (E-R) model and Relational Model.\n2. **Database Languages**: Data Definition Language (DDL), Data Manipulation Language (DML), and Query Language are used to interact with the database.\n3. **Security**: Access control is crucial to ensure data consistency and integrity, as multiple users may update data simultaneously.\n4. **Concurrency Control**: To prevent inconsistencies, mechanisms like locking, optimistic concurrency, and pessimistic concurrency are employed.\n5. **Data Abstraction**: Data abstraction allows for different levels of detail to be presented to different users or applications.\n\n**Database Architecture**\n\n* A DBMS consists of three main components: Storage Manager, Query Processor, and Application Program Interface (API).\n* The Storage Manager manages physical storage and provides a interface to the database.\n* The Query Processor compiles and executes DDL and DML statements.\n* The API provides a interface for applications to interact with the database.\n\n**Users and Applications**\n\n* **Naive Users**: Unsophisticated users who interact with the system through pre-written application programs or forms interfaces.\n* **Application Programmers**: Computer professionals who write application programs using DBMS-provided tools and languages.\n* **Sophisticated Users**: Users who submit queries to explore data in the database, using a query language.\n\nI hope this summary helps! Let me know if you have any further questions.", "105": "Here is a concise summary of the text:\n\nThe evolution of user-database interactions has progressed from intermediaries like bank tellers and airline reservation agents to direct access through automated teller machines (ATMs) and interactive voice response systems. The internet revolution further increased direct access, with organizations converting phone interfaces to web interfaces, making various services and information available online. This allows users to interact directly with databases through websites, accessing and storing data such as book collections, orders, bank balances, and transaction history. Additionally, user behavior and preferences may be tracked and stored in databases for targeted advertising purposes, illustrating the increasing reliance on database interactions in modern digital communication.", "18": "Here is a concise summary of the text:\n\nThe importance of database systems lies in their ubiquitous presence in modern life, powering online interactions, data storage, and personalized advertising. Database systems are distinct from file systems, as they provide a structured approach to storing and managing information, enabling efficient retrieval and manipulation of data. A database administrator (DBA) plays a crucial role in designing, maintaining, and securing the database system, including tasks such as schema modification, authorization management, routine maintenance, and transaction management. The text also highlights the evolution of a file-processing system, such as a savings bank's customer information system, which requires continuous updates to application programs and storage structures to accommodate changing business needs. Overall, the summary emphasizes the significance of database systems in today's digital world.", "11": "Here is a concise summary of the text:\n\nThe history of data processing and storage dates back to the early 20th century, with punched cards used to record census data and mechanical systems for tabulating results. Over time, techniques have evolved, including the development of magnetic tapes in the 1950s and 1960s. The need for efficient data management led to the creation of database management systems (DBMS). DBMS provides a structured way to store, retrieve, and manipulate data, unlike traditional file-processing systems which can lead to redundancy, inconsistency, and higher storage costs.\n\nThe text highlights the importance of DBMS in today's digital world, where databases are used in various applications such as banking, web access, and marketing. It also emphasizes the need for a DBMS to ensure consistency and atomicity in transactions, and to recover from failures.\n\nThe main concepts discussed include:\n\n1. The evolution of data processing and storage techniques.\n2. The differences between file-processing systems and DBMS.\n3. The importance of physical and logical data independence.\n4. The responsibilities of a DBMS and the problems that would arise if these responsibilities were not discharged.\n5. The functions of a database administrator.\n\nOverall, the text provides an introduction to the concept of DBMS and its significance in modern computing.", "7": "Here is a concise summary of the text, focusing on the key concepts:\n\nThe text discusses the evolution of database systems, data models, and query languages. The relational model, introduced by Codd in 1970, revolutionized databases by providing a declarative way to access data. This led to the development of relational databases such as IBM DB2, Oracle, and SQL/DS.\n\nKey concepts:\n\n1. Data Models: Relational, Entity-Relationship (E-R), Object-Oriented, and Semistructured models are discussed.\n2. Query Languages: Declarative languages like SQL and procedural languages are mentioned.\n3. Database Systems: Evolution of database systems from hierarchical to network to relational databases is outlined.\n4. Storage Manager: A program module responsible for interacting with the file manager and physical storage is described.\n5. Application Architectures: Two-tier and three-tier architectures, client-server models, and application program interfaces (APIs) like ODBC and JDBC are discussed.\n6. Data Abstraction: The text highlights the importance of data abstraction, where high-level views simplify access to data while hiding implementation details.\n\nThe summary focuses on the main ideas, skipping unnecessary details. Let me know if you have any further requests!", "106": "Here is a concise summary of the text:\n\nA banking enterprise maintains customer information on a computer using files stored within an operating system. Application programs manipulate these files to manage account operations, such as debiting/crediting, adding new accounts, finding balances, and generating statements. As business needs evolve, additional application programs are developed to address specific requirements, like offering checking accounts with features like overdrafts. Over time, the system grows by acquiring more files and programs, supported by a conventional operating system that manages permanent records and requires different programs to extract or add information.", "9": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses the evolution of database management systems (DBMS) and the need for abstraction to simplify user interactions. In traditional file-processing systems, data redundancy and inconsistency occur due to different formats and programming languages used by various programmers over time. This approach is inadequate for large-scale enterprises.\n\nTo address these issues, DBMSs partition their structure into modules: storage manager and query processor components. The storage manager handles large amounts of data storage space, while the query processor handles user queries. To hide complexity from users, multiple levels of abstraction are employed:\n\n1. Physical level: describes how data is actually stored.\n2. Logical level: describes what data is stored and relationships among them.\n3. View level: provides a security mechanism to prevent unauthorized access.\n\nThe text also introduces the concepts of instances and schemas, highlighting how databases change over time as new applications and files are added. Ultimately, DBMSs strive to balance complexity with usability by providing multiple levels of abstraction for users, administrators, and programmers.", "8": "Here is a concise summary of the text:\n\nBefore the advent of Database Management Systems (DBMS), organizations stored information using file-processing systems, which had several disadvantages. The main issues were data redundancy and inconsistency, where the same information was duplicated in multiple files, leading to higher storage and access costs. Additionally, this approach led to inconsistencies between different copies of the same data. A relational database, on the other hand, stores information in a more organized and consistent manner, with relationships between data entities stored in separate tables (e.g., customer, account, depositor). This approach eliminates redundancy and inconsistency, providing a more efficient and effective way to manage and retrieve information.\n\nKey concepts:\n\n1. File-processing systems: storing information in multiple files, each with its own format and programming language.\n2. Data redundancy and inconsistency: the same information duplicated in multiple places, leading to inconsistencies between different copies of the same data.\n3. Relational databases: a more organized and consistent way to store information, with relationships between data entities stored in separate tables.\n\nKey connections:\n\n1. The file-processing system is supported by a conventional operating system.\n2. The relational database eliminates redundancy and inconsistency by storing related data in separate tables.\n3. The relational database provides a more efficient and effective way to manage and retrieve information compared to the file-processing system.", "44": "Here's a concise summary of the text:\n\nBefore Database Management Systems (DBMS) emerged, organizations typically used file-processing systems to store information. These systems had several disadvantages, including data redundancy and inconsistency. Different programmers created files in various formats, leading to duplicated information and potential inconsistencies. To manage this information, application programs were written to manipulate the files, but this approach had limitations. For example, when a bank decides to offer new services like checking accounts, it needs to create new files and write new application programs, which can lead to more complexity and maintenance issues. The text highlights the inefficiencies of file-processing systems and sets the stage for the introduction of DBMSs as a solution to these problems.", "107": "Here is a concise summary of the text:\n\nIn traditional file-processing systems, information is stored in files with different formats, and separate application programs are needed to extract or add records. This approach has several drawbacks, including data redundancy and inconsistency. As different programmers create files and programs over time, similar information may be duplicated across multiple files, leading to increased storage and access costs. Additionally, this redundancy can lead to data inconsistencies, where different copies of the same data no longer agree. The limitations of file-processing systems motivated the development of Database Management Systems (DBMS), which aim to provide a more efficient and consistent way of storing and managing organizational information.", "45": "Here is a concise summary of the text:\n\nPrior to the development of Database Management Systems (DBMS), organizations stored information using conventional file-processing systems. This approach had several drawbacks, including data redundancy and inconsistency. Different programmers created files with varying formats and programming languages, leading to duplicated information across multiple files. For instance, customer information might be stored in separate files for savings and checking accounts. This redundancy resulted in increased storage and access costs, as well as potential data inconsistencies where different copies of the same information no longer agreed.", "46": "Here is a concise summary of the text:\n\nThe existing banking system relies on checking account records, leading to storage and access costs, as well as potential data inconsistencies. For example, changes may not be reflected across all systems. Additionally, there can be difficulties in accessing specific data, such as generating a list of customers within a particular postal code area. The lack of anticipation for this request means that there is no existing application program to meet the need, leaving two options: manually extracting the needed information or asking a system programmer to write a new application program.", "47": "Here is a concise summary of the text:\n\nThe existing banking system consists of separate checking account records, leading to redundancy, increased storage and access costs, and potential data inconsistencies. This redundancy can cause issues when accessing or updating data, such as difficulties in finding specific customer information. For instance, if a bank officer needs to generate a list of customers within a particular postal code area, the system may not have a pre-built application program to meet this request, requiring manual extraction of relevant information or requesting a programmer to create a new program.", "108": "Here is a concise summary of the text:\n\nThe current banking system consists of separate checking account records, leading to redundant storage, increased access costs, and potential data inconsistencies. This design flaw can cause difficulties in accessing specific data, such as generating a list of customers within a particular postal code area. In this scenario, there are no pre-existing application programs to meet the request, forcing the bank officer to either manually extract the needed information from an existing list or ask a system programmer to create a new program.", "109": "Here is a concise summary of the text:\n\nThe original bank accounting system has multiple copies of customer data, leading to redundancy, increased storage and access costs, and potential data inconsistencies. For instance, if a customer's address changes in one copy of their record, it may not be reflected elsewhere. Additionally, the system lacks flexibility in accessing data, as demonstrated by the scenario where a bank officer needs to generate a list of customers within a specific postal code area, but there is no existing application program to meet this request.", "110": "Here's a concise summary of the text:\n\nThe introduction highlights the limitations of conventional file-processing environments, which make it difficult to efficiently retrieve specific data from scattered and formatted files. Two undesirable alternatives are presented: manual extraction or asking a system programmer to create an application program. This leads to issues with data isolation (scattered data in different formats) and integrity problems (consistency constraints). The author suggests that more responsive data-retrieval systems are needed for general use, emphasizing the importance of addressing these limitations.", "33": "Here is a concise summary of the text:\n\nThe introduction highlights the limitations of traditional file-processing environments, where retrieving specific data requires manual extraction or custom programming, which is inefficient and unsatisfactory. The main issues are: (1) data isolation, where scattered data across different files and formats makes it difficult to retrieve relevant information; and (2) integrity problems, such as ensuring consistency constraints, like the balance of a bank account being accurate. These challenges illustrate the need for more responsive data-retrieval systems that can efficiently and conveniently provide needed data.", "48": "Here is a concise summary of the text:\n\nThe introduction highlights the limitations of traditional file-processing environments, where users are forced to choose between manual extraction of needed information or writing custom application programs. This leads to inefficiency and inconvenience. The two main issues identified are data isolation (data being scattered across various files in different formats) and integrity problems (the need for consistency constraints in database values). The author suggests that more responsive data retrieval systems are required to address these challenges, implying the need for a new approach to managing and accessing data.", "111": "Here is a concise summary of the text:\n\nThe introduction highlights the limitations of conventional file-processing environments, which do not provide efficient and convenient ways to retrieve needed data. Two examples illustrate this point: an officer needs to extract information from a list of customers, but either manually extracting the data or writing a custom program are unsatisfactory solutions. The main challenges are data isolation (data is scattered across different files in varying formats) and integrity problems (data values must satisfy certain consistency constraints). These limitations demonstrate the need for more responsive data-retrieval systems to support general use.", "34": "Here is a concise summary of the text:\n\nThe introduction highlights the limitations of conventional file-processing environments, where retrieving specific data requires manual extraction or custom programming. This leads to issues with data isolation (scattered across various files and formats) and integrity problems (consistency constraints not satisfied). The relational model is introduced as a widely used data model that hides low-level implementation details from developers and users. This model will be covered in detail in chapters 3-7, while chapter 2 describes the translation process from the entity-relational model to the relational model.", "49": "Here's a concise summary of the text:\n\nEnsuring data integrity and atomicity are crucial challenges in designing database systems. Data integrity issues arise when ensuring that stored values meet certain constraints, such as a bank account balance never falling below a certain amount. Enforcing these constraints requires adding code to application programs, but this can be difficult and complicated by involving multiple files. Atomicity problems occur when system failures disrupt transactions, leaving the database in an inconsistent state. For example, transferring $50 from one account to another might leave the original account's balance reduced but not credited to the target account. To maintain database consistency, it is essential that all aspects of a transaction either succeed or fail together, ensuring that data remains consistent and accurate.", "112": "Here's a concise summary of the text:\n\nThe challenges of managing data integrity and consistency in databases involve two key problems: enforcing constraints and maintaining atomicity. Integrity issues arise when data values must satisfy certain conditions, such as ensuring a bank account balance never falls below a certain amount. Developing programs to enforce these constraints is difficult, especially when new constraints are added or involve multiple data items from different files. Atomicity issues occur when system failures can leave the database in an inconsistent state. For instance, transferring $50 between two accounts may be interrupted, leaving one account credited but not the other. To ensure consistency, it's crucial that all transactions either complete successfully or roll back to a consistent previous state.", "14": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nA database consists of multiple schemas (designs) that change over time as information is inserted or deleted. The overall design is called the schema, while the collection of information at a particular moment is an instance of the database. Database systems have different levels of abstraction, including physical, logical, and view schemas.\n\nTo maintain data consistency, developers must enforce constraints, such as ensuring that a bank account balance never falls below a certain amount. However, adding new constraints can be challenging, especially when they involve multiple data items from different files.\n\nThe entity-relationship (E-R) model is widely used in database design to represent entities, attributes, and relationships. It also represents constraints, such as mapping cardinalities that ensure, for example, that each account belongs to only one customer.\n\nThree key problems arise when designing databases: integrity problems (ensuring data consistency), atomicity problems (restoring the database to a consistent state after a failure), and concurrent-access anomalies (ensuring data consistency when multiple users update the database simultaneously).", "17": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe chapter introduces the concept of database systems, highlighting their advantages over file-processing systems. It discusses physical and logical data independence, emphasizing that a DBMS should provide both to ensure flexibility and scalability. The importance of transactions, concurrency control, and atomicity is stressed, as simultaneous updates can lead to inconsistent data. Additionally, security concerns are mentioned, as not all users should have access to all data.\n\nThe text also touches on database models, including entity-relationship, relational, and object-oriented models. It provides examples of record-based models, such as the relational model, which structures data into fixed-format records with defined attributes (columns). The chapter concludes by emphasizing the need for DBMSs to provide mechanisms for ensuring data consistency, concurrency control, and security.\n\nKey concepts:\n\n* Physical and logical data independence\n* Transactions and atomicity\n* Concurrency control and simultaneous updates\n* Database models (entity-relationship, relational, object-oriented)\n* Security and access control", "113": "Here is a concise summary of the text:\n\nThe text discusses two key concepts: concurrency and security. In a banking system, when multiple programs execute concurrently to update account balances, they may overwrite each other's changes, leading to incorrect values. To prevent this, the system must ensure consistency and maintain some form of supervision. Additionally, not all users should have access to all data, as demonstrated by payroll personnel needing limited access to employee information while not requiring access to customer accounts. The challenge lies in coordinating application programs that are added to the system ad hoc, making it difficult to provide effective supervision and security controls.", "6": "Here is a concise summary of the provided text, focusing on the key concepts:\n\nThe text introduces database systems, which manage large amounts of data and provide various levels of abstraction to simplify interaction with the data. The three levels of abstraction are: Logical Level (views), Physical Level (data dictionary), and View Level (data models). A database system consists of a storage manager, query processor, and query evaluation engine.\n\nThe text also discusses different types of users, including:\n\n1. Naive Users: interact with the system through forms interfaces or by reading reports generated from the database.\n2. Application Programmers: write application programs to access the database.\n3. Sophisticated Users: form requests in a query language and submit queries to the query processor.\n\nThe text also covers data models, including:\n\n1. Entity-Relationship Model (E-R model): represents relationships between entities using tables and relationships.\n2. Relational Model: uses tables with columns and rows to represent data and relationships.\n3. Object-Oriented Data Model: represents data as objects with attributes and methods.\n\nThe text also discusses database languages, including:\n\n1. Data Definition Language (DDL)\n2. Data Manipulation Language (DML)\n3. Query Language\n\nFinally, the text mentions various types of database architectures, including two-tier and three-tier architectures, which partition the application into different parts running on different machines.\n\nKey concepts include:\n\n* Database systems and their components\n* Levels of abstraction: logical, physical, and view levels\n* Types of users: naive, application programmers, and sophisticated users\n* Data models: E-R model, relational model, object-oriented data model\n* Database languages: DDL, DML, query language\n* Database architectures: two-tier and three-tier architectures", "114": "Here is a concise summary of the text:\n\nThe development of database systems was prompted by difficulties in enforcing security constraints and accessing relevant information in file-processing systems. In a traditional file-processing system, payroll personnel may only need access to employee information, but application programs are added ad-hoc, making it challenging to ensure secure data access. A database system provides an abstract view of the data, hiding details about how data is stored and maintained, allowing users to focus on retrieving and modifying relevant information efficiently. The use of complex data structures and algorithms enables databases to solve these problems and provide a usable solution for applications like a bank enterprise.", "50": "Here is a concise summary of the text:\n\nA database system serves as an intermediary between users and stored data, allowing analysts to explore and analyze data through query processing. Two main categories of users are analysts who submit queries to view summaries or discover patterns using OLAP (Online Analytical Processing) tools and data mining techniques. Another category is specialized users, such as payroll personnel, who require tailored access to specific parts of the database without compromising security constraints. A key concept in databases is data abstraction, which hides storage and maintenance details from users, providing an abstract view of the data. To achieve efficiency, complex data structures are used to represent data, enabling efficient retrieval and manipulation.", "115": "Here is a concise summary of the text:\n\nThe development of database systems was prompted by the difficulties of enforcing security constraints and retrieving data efficiently in file-processing systems. A key concept in database systems is data abstraction, which allows users to access and modify data without needing to know how it's stored or maintained. In a database system, users see only the relevant information (e.g., employee records) while hiding irrelevant details (e.g., customer account information). This abstract view of data enables efficient retrieval of needed data, making database systems more usable than file-processing systems.", "116": "Here is a concise summary of the text:\n\nThe development of database systems was prompted by difficulties in enforcing security constraints and managing large amounts of data in file-processing systems. A database system provides users with an abstract view of data, hiding underlying storage and maintenance details. This requires efficient retrieval of data, which has led designers to use complex data structures. The main goal is to provide users with a restricted view of specific parts of the data, such as employee information in a bank, while concealing other irrelevant data, like customer accounts.", "117": "Here is a concise summary of the text:\n\nTo make a database system usable, data must be retrieved efficiently. To achieve this, complex data structures are used to represent data in the database. However, users who are not computer-trained need a simplified way to interact with the system. This is achieved through several levels of abstraction: physical and logical. The physical level describes how data are stored in detail, while the logical level describes what data are stored and their relationships without revealing the underlying complexity. Database administrators use the logical level to decide what information to store, while users only need to interact with this higher-level abstraction, unaware of the complex physical-level structures involved.", "118": "Here is a concise summary of the text:\n\nTo make a database system usable, data must be retrieved efficiently, which has led to the development of complex data structures. To simplify interactions with the system, developers use multiple levels of abstraction, hiding complexity from users. The physical level describes how data are actually stored in detail, while the logical level abstracts away from this complexity, describing what data are stored and their relationships using simple structures. This allows database administrators to focus on deciding what information to store without worrying about the underlying complexities.", "35": "Here is a concise summary of the text:\n\nThe three levels of abstraction in database systems are the physical, logical, and view levels. The physical level describes how data is actually stored, using complex low-level structures. The logical level describes what data is stored and its relationships, using simpler structures that hide complexity from users. The view level provides a simplified interface for users to interact with the system, offering many views of the same database. These levels allow database administrators to manage complex databases while hiding complexity from users who only need to access parts of the database. This abstraction also parallels data typing in programming languages, where record types can be thought of as abstract representations of data structures that hide implementation details.", "119": "Here is a concise summary of the text:\n\nDatabase complexity arises from the need to manage large amounts of information. Database administrators use the logical level of abstraction, which describes the structure of the database using simpler representations. However, this level still captures only part of the entire database, leading to complexity due to the variety of stored data. To simplify interactions with the system, a view level of abstraction is introduced, allowing users to access only specific parts of the database. The three levels of abstraction - physical, logical, and view - are interconnected, with the view level providing multiple views for the same database (illustrated in Figure 1.1). An analogy is drawn between data types in programming languages, where a record type can be declared as an example of the concept of abstraction levels.", "120": "Here is a concise summary of the text:\n\nDatabase complexity arises from the need to manage varying levels of abstraction. The logical level, used by database administrators, focuses on deciding what information to store. However, this level still struggles with complexity due to the sheer amount of data stored in large databases. To simplify user interaction, the view level of abstraction is introduced, which presents a subset of the entire database to users who only need access to specific parts. The text also uses an analogy from programming languages (record types) to illustrate the distinction between these levels of abstraction.", "51": "Here is a concise summary of the text:\n\nThe concept of records and record types is introduced, with an example in a Pascal-like language defining a \"customer\" record type with four fields (customer ID, name, street, and city). At a physical level, each record can be viewed as a block of consecutive storage locations. This is part of the three levels of data abstraction: logical (the actual data structures), physical (the storage representation), and view (the user's perspective, abstracted away from physical details). The compiler hides these physical-level details from programmers, while database systems hide many low-level storage details from database programmers.", "36": "Here is a concise summary of the text:\n\nThe text discusses record types in programming languages, such as Pascal-like languages. A record type defines a new data structure with multiple fields, each with a name and type. For example, a \"customer\" record might have fields for customer ID, name, street, and city. At the physical level, these records are stored in consecutive locations (e.g., words or bytes). This is an example of the logical-physical dichotomy in data abstraction, where the language hides storage details from programmers. Similarly, a database system hides low-level storage details from database programmers, while revealing them to administrators who manage the physical storage of data.", "121": "Here is a concise summary of the text:\n\nThe text discusses the different levels of abstraction in a database system, which are similar to those found in programming languages. At the physical level, the database system hides storage details from programmers and administrators. The logical level involves defining record types and their relationships, which programmers and administrators work at. Finally, the view level provides users with a set of application programs that hide data type details, while also serving as a security mechanism to restrict access to certain parts of the database. This is exemplified by a bank where tellers can only see customer account information, not employee salaries.", "5": "Here is a concise summary of the text focusing on key concepts and their connections:\n\nThe text discusses database systems, which enable users to access or manipulate data organized by an appropriate data model. There are two types of Data Manipulation Languages (DMLs): procedural DMLs, which require users to specify what data are needed and how to get them, and declarative DMLs, which only require users to specify what data are needed without specifying how to get them. The SQL language is an example of a declarative DML.\n\nA database system consists of several components, including the buffer manager, storage manager, and query processor. The query processor translates DML statements into evaluation plans that can be executed by the query evaluation engine.\n\nThe text also discusses database languages, which include Data Definition Language (DDL) for specifying the database schema and DML for expressing queries and updates. The SQL language is an example of a single database language that combines both DDL and DML.\n\nIn addition, the text introduces the concept of transactions, which are sequences of operations that preserve the consistency of the database. It also discusses the importance of data independence, physical schema, logical schema, and metadata in database systems.\n\nThe text further explores database users and administrators, including their roles and responsibilities. Finally, it touches on application architectures, such as two-tier and three-tier architectures, which enable remote database access through a network.\n\nOverall, the text provides an introduction to database systems, covering key concepts, components, languages, and architectures that underlie modern databases.", "122": "Here is a concise summary of the text:\n\nThe article discusses the concept of levels of abstraction in databases, similar to how programming languages have different levels of abstraction. The lowest level is physical storage, which is hidden from programmers and database administrators. At the logical level, each record type is defined and interrelated, allowing programmers and database administrators to work at this level of abstraction. Finally, at the view level, users see a set of application programs or views that hide details of the data types, providing security by limiting access to certain parts of the database. This structure enables different stakeholders (programmers, database administrators, and end-users) to operate at their respective levels of abstraction, without requiring them to understand the underlying physical storage details.", "123": "Here is a concise summary of the text:\n\nThe article discusses the different levels of abstraction in a database system, from physical storage details to logical record types and finally, views that hide underlying data types from users. Database administrators typically work at the logical level, defining record types and their relationships, while programmers using a programming language also operate at this level. At the view level, computer users interact with a set of application programs that provide a security mechanism by hiding certain parts of the database, ensuring that users only access authorized information (e.g., tellers in a bank can only see customer account data).", "124": "Here is a concise summary of the text:\n\nThe text discusses the different levels of abstraction when working with data models, highlighting three key layers: physical, logical, and view. The physical level involves low-level storage details, which are hidden from programmers and database administrators. At the logical level, record types are defined, along with their interrelationships, and this is where programmers and database administrators typically work. Finally, at the view level, users see a set of application programs that hide data type details, providing security by limiting access to certain parts of the database. For example, bank tellers can only access customer account information, not employee salaries. The text also mentions that databases change over time through instances and schemas.", "125": "Here is a concise summary of the text:\n\nA database consists of two main components: schemas and instances. The schema refers to the overall design or structure of the database, which remains relatively unchanged over time. This corresponds to variable declarations in a program, with each variable having a specific value at a given moment (instance). A database system typically has multiple schemas, organized by levels of abstraction. These include physical, logical, and view-level schemas. The physical schema describes the design at the physical level, while the logical schema describes it at the logical level. Meanwhile, instances refer to the collection of information stored in the database at a particular moment, which can change over time as data is inserted or deleted.", "126": "Here is a concise summary of the text:\n\nA database consists of two main components: the schema and instances. The schema refers to the overall design of the database, which remains relatively unchanged over time, while an instance represents the collection of information stored in the database at a specific moment. This concept can be compared to programming, where a variable's value at a given instant corresponds to an instance of a program. A database may have multiple schemas, including physical, logical, and view levels, each describing different aspects of the database design. For example, tellers in a bank only see parts of the database related to customer accounts, but not employee salaries.", "127": "Here is a concise summary of the text:\n\nA database consists of two main components: the schema and instances. The schema refers to the overall design or structure of the database, which remains relatively unchanged over time. This corresponds to the variable declarations in a program, where each variable has a specific type and value at a given instant. An instance, on the other hand, is the collection of data stored in the database at a particular moment. Database systems typically have multiple schemas, including physical, logical, and view levels, which partition the data according to different levels of abstraction.", "16": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nA database system consists of several subsystems, including the transaction manager, query processor, and storage manager. The overall design of the database is called the schema, which can be categorized into physical, logical, and view levels. A schema can have multiple instances, with each instance representing a collection of data stored in the database at a particular moment.\n\nThe concept of database schemas and instances can be understood by analogy to programming languages, where a program's variable declarations correspond to a database's schema. The logical schema is the most important level, as it affects application programs. Physical data independence allows application programs to function regardless of changes to the physical schema.\n\nThe text also introduces data models, which are conceptual tools for describing data, relationships, semantics, and consistency constraints. Two examples of data models mentioned are the entity-relationship model and the relational model. The relational model uses tables to represent data and relationships, while the entity-relationship model describes entities and their relationships.\n\nOverall, the text provides an overview of database systems, including their design, schema levels, instances, and data models.", "128": "Here is a concise summary of the text:\n\nThe concept of databases can be understood through the analogy of programming languages. A database schema represents the overall design and structure of the database, similar to variable declarations in a program. An instance of the database refers to the specific collection of information stored at a particular moment in time, corresponding to the values of variables in a program. The database may have multiple schemas, partitioned into physical, logical, and view levels, each describing different aspects of the database design. For example, tellers in a bank can only access their portion of the database, such as customer account information, while not having access to employee salaries.", "129": "Here is a concise summary of the text:\n\nA database consists of two main components: the schema and the instance. The schema represents the overall design of the database, while an instance refers to the collection of data stored in the database at a particular moment. Just like a program has variables with specific values at a given instant, a database's schema corresponds to variable declarations, and each instance is equivalent to the current values of those variables. Database systems often have multiple schemas, including physical, logical, and view levels, which partition the data according to abstraction levels. For example, in a bank, tellers may only see a specific part of the database containing customer account information, while not having access to employee salaries.", "52": "Here is a concise summary of the text:\n\nA database consists of schemas and instances. A schema refers to the overall design of the database, while an instance represents the collection of information stored at a particular moment in time. Schemas can be partitioned into different levels of abstraction, including physical, logical, and view (sub)schemas. The logical schema is particularly important because it serves as the foundation for application programs, which are constructed using this schema. Changes to the physical schema do not typically affect application programs, making them exhibit physical data independence. Data models, on the other hand, provide a conceptual framework for describing data, relationships, semantics, and consistency constraints underlying the structure of a database.", "15": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nA Database Management System (DBMS) consists of interrelated data and programs to access that data. The primary goal of a DBMS is to provide an environment for convenient and efficient retrieval and storage of information. The relational model is the most widely used data model, and it hides low-level implementation details from database developers and users.\n\nA DBMS provides two main languages: Data Definition Language (DDL) for specifying the database schema, and Data Manipulation Language (DML) for expressing queries and updates. The logical schema describes the database design at a higher level of abstraction than the physical schema, which is hidden beneath it.\n\nThe entity-relationship model is another important data model that describes entities and relationships between them. The relational model uses tables to represent both data and relationships among those data.\n\nA DBMS is partitioned into modules that deal with each responsibility of the overall system. The storage manager and query processor are two key components. Data models, such as the relational model, entity-relationship model, and object-oriented data model, provide a collection of conceptual tools for describing data, relationships, semantics, and consistency constraints.\n\nThe text also discusses database languages, data abstraction, physical data independence, and metadata. Overall, it provides an introduction to the concepts and components of a DBMS, highlighting their connections and importance in modern computing.", "130": "Here is a concise summary of the text:\n\nThe Entity-Relationship (E-R) data model describes the design of a database at its logical level by representing real-world objects as \"entities\" with attributes that describe their characteristics. Entities are distinguishable from one another, such as people or bank accounts, and are described using sets of attributes. For example, an account entity may have attributes like account number and balance, while a customer entity may have attributes like name, street address, and city. This model focuses on the relationships between entities, which is crucial for capturing data semantics and ensuring consistency constraints in a database system.", "131": "Here's a concise summary of the text:\n\nThe Entity-Relationship (E-R) diagram is a graphical representation of a database's logical structure, comprising rectangles for entity sets, ellipses for attributes, diamonds for relationships, and lines linking these components. In the example of a banking system, the E-R diagram shows two entity sets (customers and accounts) with attributes and a relationship between them (depositor). The model also represents constraints that ensure data consistency, such as mapping cardinalities, which define the number of entities associated via a relationship set. For instance, the constraint can state that each account belongs to only one customer. The E-R model is widely used in database design for its ability to visually represent and organize complex database structures.", "132": "Here is a concise summary of the text:\n\nThe Entity-Relationship (E-R) diagram is a graphical representation of a database's logical structure, consisting of rectangles for entity sets, ellipses for attributes, diamonds for relationships, and lines linking these components. An example E-R diagram illustrates a banking system with customers and accounts, including a relationship between customer and account. The model also represents constraints, such as mapping cardinalities, which define the number of entities that can be associated via a relationship set. For instance, if each account belongs to only one customer, this constraint can be expressed in the E-R model.", "133": "Here is a concise summary of the text:\n\nThe Entity-Relationship (E-R) diagram is a graphical representation of a database's logical structure, comprising rectangles (entity sets), ellipses (attributes), diamonds (relationships), and lines linking these components. The E-R model for a banking system example shows two entity sets (customers and accounts) with attributes, as well as a relationship between customers and accounts (depositor). Additionally, the model represents constraints that ensure the database contents conform to specific rules, such as mapping cardinalities, which dictate the number of entities associated via a relationship. The E-R model is widely used in database design due to its ability to visually represent complex relationships and constraints, facilitating effective database management.", "12": "Here is a concise summary of the text, focusing on the key concepts and their connections:\n\nThe relational model is a data modeling approach that structures databases into tables (or relations) with fixed-format records. Each table contains records of a particular type, defined by a fixed number of fields or attributes. The columns of the table correspond to the attributes of the record type. This model hides low-level implementation details from database developers and users.\n\nThe relational model is widely used in current database systems, with many commercial database systems available, such as IBM DB2, Oracle, Microsoft SQL Server, Informix, and Sybase. Free or public domain alternatives include MySQL and PostgreSQL.\n\nThe evolution of databases can be traced back to the 1960s and 1970s, when data processing programs were forced to process data in a particular order due to limitations on sequential access to tapes and card decks. The introduction of hard disks in the late 1960s allowed direct access to data, freeing it from sequentiality.\n\nThe relational model was formally defined by Codd in 1970, introducing non-procedural ways of querying data. This led to the development of relational databases, which were initially perceived as having performance disadvantages compared to existing network and hierarchical databases. However, System R, a groundbreaking project at IBM Research, developed techniques for constructing an efficient relational database system.\n\nThe entity-relationship (E-R) model is another widely used approach in database design, which represents the overall logical structure of a database using rectangles, ellipses, diamonds, and lines to depict entities, attributes, relationships, and constraints. The E-R diagram shows the relationships between entities and attributes, as well as certain constraints that must be enforced.\n\nOverall, the relational model and its evolution have had a significant impact on the development of databases, enabling efficient querying and manipulation of data, while hiding low-level implementation details from users.", "134": "Here is a concise summary of the text:\n\nThe Entity-Relationship (E-R) model is a data modeling technique used to describe relationships between entities, such as accounts belonging to customers. It allows constraints like \"each account must belong to only one customer\" to be expressed. The E-R model is widely used in database design and is explored in detail in Chapter 2. In contrast, the Relational Model uses a collection of tables to represent data and relationships, with each table having multiple columns and unique names. A sample relational database diagram is presented, showing three tables: customer details, account information, and account-customer relationships.", "135": "Here is a concise summary of the text:\n\nThe text discusses two data models: Entity-Relationship (E-R) model and Relational model. In the E-R model, entities are represented as tables with attributes (e.g., customer name, street), and relationships between entities are defined using relationship sets. For instance, an E-R diagram can constrain that each account belongs to only one customer. The Relational model, on the other hand, represents data using a collection of tables (tables) with columns and unique names. A sample relational database is presented, comprising three tables: customers, accounts, and account-customer relationships.", "136": "Here is a concise summary of the text:\n\nThe relational data model organizes data into tables, each containing records with fixed attributes (fields) that can be stored in files. Records are separated by special characters, such as newline characters, and fields within a record are separated by other special characters, like commas. This model hides low-level implementation details from users and developers, making it widely used and the basis for most current database systems. The relational model is more concrete than the entity-relationship (ER) model, which is often used to design databases before translating them into the relational model.", "137": "Here is a concise summary of the text:\n\nThe relational data model is a widely used approach to storing and organizing data, where each \"table\" contains records of a specific type with fixed attributes (or fields). Each record type defines a set of attributes that correspond to the columns in the table. The relational model hides low-level implementation details from developers and users, making it easy to store tables in files using delimiters such as commas and newlines. This model is more concrete than the Entity-Relationship (E-R) model, which is often used for database design before being translated into a relational model.", "138": "Here is a concise summary of the text:\n\nThe relational data model is a widely used approach to organizing data in databases. It consists of tables, each containing records of a specific type with fixed numbers of attributes (columns). The relational model abstracts away low-level implementation details, allowing developers and users to focus on higher-level concepts. The relational model is often translated from the Entity-Relationship (E-R) model, which provides a higher level of abstraction for designing databases. Tables in the relational model correspond to entity sets or relationship sets in the E-R model, making it easy to translate between the two models.", "53": "Here is a concise summary of the text:\n\nThe provided text illustrates a sample relational database with three tables: \"customer\", \"account\", and \"depositor\". The key concept is that each table has unique attributes, such as customer ID and account number. Specifically, the \"customer\" table stores information about individual customers (e.g., name, street, city), while the \"account\" table stores details about their accounts (e.g., balance). The connection between customers and accounts is established by storing the account numbers as an attribute of the customer records in the \"customer\" table.", "139": "Here is a concise summary of the text:\n\nThe provided text illustrates a sample relational database, specifically three tables: \"customer\", \"account\", and \"depositor\". The \"customer\" table has attributes such as customer ID, name, street, and city. The \"account\" table contains account numbers, which are linked to the \"customer\" table through the attribute \"account number\". This design allows for the representation of relationships between customers and their accounts, such as two accounts (101 and 201) belonging to the same customer (Johnston). This relational database structure enables efficient storage and retrieval of data by avoiding unnecessary duplication of values.", "54": "Here's a concise summary of the text:\n\nThe text discusses various data models and their limitations. Specifically, it highlights the problem of storing multiple rows for the same customer in a relational database, which can lead to unnecessary duplication of values. The text also touches on other data models, including the object-oriented model, which extends the entity-relationship (ER) model with concepts like encapsulation, methods, and object identity. Additionally, it mentions the object-relational data model, which combines features of both the object-oriented and relational data models. Finally, it introduces semistructured data models, which permit different sets of attributes for individual data items of the same type.", "55": "Here is a concise summary of the text:\n\nThe text discusses various data models, including relational, object-oriented, and semistructured models. The relational model is the most common, but it has limitations when dealing with complex relationships between data items. Object-oriented and semistructured models offer more flexibility by allowing for methods and attributes to be defined on individual data items. Semistructured models are particularly useful when data items of the same type may have different sets of attributes. The text also touches on historical data models, such as network and hierarchical models, which were tied closely to implementation details and are no longer widely used. Finally, it mentions database languages, including SQL, which combines data definition and manipulation capabilities into a single language.", "140": "Here is a concise summary of the text:\n\nThe chapter discusses semistructured data models, which allow individual data items to have different sets of attributes, unlike traditional data models where all data items of the same type must have the same attributes. XML (Extensible Markup Language) is widely used to represent semistructured data. The chapter also touches on historical data models, such as network and hierarchical data models, which are no longer commonly used due to their tight connection to implementation details. Finally, it introduces database languages, specifically data definition language (DDL) for specifying the database schema and data manipulation language (DML) for querying and updating databases.", "141": "Here is a concise summary of the text:\n\nThe chapter discusses semistructured data models, which allow individual data items to have different attributes. This contrasts with earlier data models that required all data items of the same type to have the same set of attributes. XML is commonly used to represent semistructured data. The chapter also touches on historical data models, such as network and hierarchical models, which were implementation-dependent and are now largely outdated. Additionally, the text explains that a database system typically provides a single language for defining the database schema (data definition) and performing queries and updates (data manipulation), with SQL being a widely used example of this combined language.", "142": "Here is a concise summary of the provided text:\n\nThe chapter discusses semistructured data models, which allow individual data items to have different attributes, unlike earlier data models that required uniform attribute sets. XML is widely used to represent such data. The text also touches on historical data models, including the network and hierarchical models, which are less commonly used now due to their close ties to implementation details. Finally, it highlights the importance of database languages, specifically the data definition language (DDL) for specifying database schema and the data manipulation language (DML) for expressing queries and updates, which often combine into a single language like SQL.", "56": "Here is a concise summary of the text:\n\nThe chapter discusses semistructured data models, which allow different data items to have varying attributes. This is in contrast to earlier models where all data items had the same set of attributes. XML is a widely used representation for semistructured data. The chapter also touches on historical data models such as the network and hierarchical models, which were closely tied to implementation and are no longer commonly used. Finally, it highlights that database languages typically combine data definition and manipulation languages into a single language, such as SQL.", "143": "Here is a concise summary of the text:\n\nIn practice, data definition and manipulation languages are not separate entities, but rather part of a single database language, such as SQL. A data definition language (DDL) is used to specify a database schema through a set of definitions. For example, in SQL, a statement like \"CREATE TABLE account...\" defines an \"account\" table and updates the data dictionary, which contains metadata about the data. The data dictionary provides information about the storage structure and access methods used by the database system, which are defined through a type of DDL called a data storage and definition language. This language specifies the implementation details of the database schema, typically hidden from users.", "57": "Here's a concise summary of the text:\n\nThe text discusses the concept of database languages, specifically the relationship between data definition language (DDL) and data manipulation language (DML). It highlights that DDL and DML are not separate languages, but rather parts of a single database language, such as SQL. The primary purpose of DDL is to define the structure of a database, including tables, relationships, and constraints, while DML enables users to interact with the data by retrieving, inserting, deleting, or modifying it. The text also touches on the importance of metadata, which provides information about the data itself, and how the database system consults this metadata before reading or modifying actual data.", "144": "Here is a concise summary of the text:\n\nIn practice, a data definition language (DDL) and data manipulation language are not separate languages, but rather parts of a single database language, such as SQL. A DDL defines a database schema by specifying the structure and organization of the database through statements like \"CREATE TABLE\". When executed, these statements create tables and update metadata stored in a data dictionary or data directory, which contains information about the data itself (schema). The data dictionary is consulted by the database system before accessing actual data. A specific type of DDL, called a data storage and definition language, defines the implementation details of the schema, typically hidden from users.", "145": "Here is a concise summary of the text:\n\nIn practice, data definition and manipulation languages are not separate entities but rather parts of a single database language, such as SQL. A Data Definition Language (DDL) is used to specify a database schema by defining tables and their characteristics, such as column types and lengths. For example, the SQL statement \"CREATE TABLE account (account-number CHAR(10), balance INTEGER)\" creates an \"account\" table and updates the data dictionary, which contains metadata about the table's schema. The data dictionary is consulted before reading or modifying actual data. Additionally, a Data Storage and Definition Language is used to specify the storage structure and access methods used by the database system, defining implementation details of the database schemas that are usually hidden from users.", "146": "Here is a concise summary of the text:\n\nThe database system uses a special type of Data Definition Language (DDL) to define the implementation details of database schemas, which are typically hidden from users. The DDL also provides facilities for specifying consistency constraints, such as ensuring an account balance does not fall below a certain amount. Database systems check these constraints every time the database is updated. Additionally, there are two types of Data Manipulation Languages (DMLs): procedural and declarative. Procedural DMLs require users to specify what data are needed and how to obtain them, whereas declarative DMLs will be discussed in later chapters.", "58": "Here is a concise summary of the text:\n\nThe database system defines its internal implementation details using Data Storage and Definition Language (DDL). These statements hide the database schema from users, while ensuring that stored data satisfies consistency constraints. For example, an account balance should not fall below $100. The DDL provides facilities to specify such constraints, which are checked every time the database is updated. Additionally, a Data Manipulation Language (DML) allows users to access or manipulate data organized by the data model, with two main types: procedural DMLs that require specifying what data is needed and how to retrieve it.", "23": "Here is a concise summary of the text:\n\nThe database system uses a Data Storage and Definition Language (DDL) to define the implementation details of database schemas, which are typically hidden from users. The DDL also allows for specifying consistency constraints, such as ensuring an account balance does not fall below $100. These constraints are checked every time the database is updated. Additionally, there is a separate concept of Data Manipulation Language (DML), which enables users to access or manipulate data stored in the database. There are two main types of DMLs: procedural and non-procedural.", "59": "Here is a concise summary of the text:\n\nData Manipulation Language (DML) enables users to access or manipulate data according to a specific data model. There are two types: procedural DMLs, which require users to specify both what data they need and how to retrieve it; and declarative DMLs (also known as non-procedural DMLs), which only require users to specify what data they need, leaving the database system to determine an efficient means of retrieval. The SQL language's DML component is declarative, and a query is a statement that requests information retrieval. While technically incorrect, it's common practice to use \"query language\" and \"DML\" interchangeably.", "60": "Here is a concise summary of the text:\n\nThe text discusses Data Manipulation Language (DML), which enables users to access or manipulate data as organized by a specific data model. There are two types of DMLs: procedural and declarative. Procedural DMLs require users to specify what data they need and how to retrieve it, while declarative DMLs only require the user to specify what data is needed, without specifying how to retrieve it. Declarative DMLs are typically easier to learn and use, but the database system must then determine an efficient way to access the data. The SQL language's DML component is nonprocedural, using query statements (also referred to as query languages) to request information retrieval.", "147": "Here is a concise summary of the text:\n\nData Manipulation Language (DML) enables users to access or manipulate data based on a specific data model. There are two types: procedural DMLs, which require specifying both what data are needed and how to retrieve them; and declarative DMLs (or non-procedural DMLs), which only specify what data are needed, leaving the database system to determine an efficient means of accessing them. The SQL language's DML component is declarative, making it easier to learn and use. A query is a statement requesting information retrieval, and the part of DML that involves information retrieval is called a query language.", "148": "Here is a concise summary of the text:\n\nData Manipulation Language (DML) enables users to access or manipulate data according to a specific data model. There are two types: procedural DMLs, which require users to specify both what data they need and how to retrieve it, and declarative DMLs, also known as nonprocedural DMLs, which only require users to specify what data they need without specifying how to get it. The SQL language's DML component is declarative, making it easier to learn and use, but requiring the database system to figure out an efficient means of accessing data. A query is a statement requesting information retrieval, and the query language portion of DML involves retrieving specific information, such as finding a customer's name based on their ID.", "149": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses the concept of database systems and users/administrators. It highlights the importance of query languages, such as SQL, in manipulating data and allowing humans to interact efficiently with the system. The text also emphasizes the levels of abstraction that apply not only to defining or structuring data but also to manipulating it. Specifically, at the physical level, algorithms are needed for efficient access to data, while at higher levels of abstraction, ease of use is prioritized. The goal is to enable humans to interact with the system effectively.", "61": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe chapter discusses the concept of database users and administrators, highlighting how a database query language can be used to retrieve data. The example given illustrates how a query would return the balances of two accounts owned by customer 192-83-7465. The authors also mention that they will study SQL, a widely-used query language, in Chapter 4, as well as other query languages in Chapter 5. The chapter emphasizes the importance of abstraction levels when manipulating data, moving from physical-level algorithms for efficient access to higher-level ease-of-use considerations for human interaction with the system.", "150": "Here is a concise summary of the text:\n\nThe text discusses the concept of database users and administrators, highlighting how a query language like SQL can be used to extract specific data from a database. The authors emphasize that manipulating data involves different levels of abstraction, from physical algorithms for efficient access at the lowest level, to ease of use for humans at higher levels. They also mention that they will study various query languages, including SQL and others, in subsequent chapters.", "151": "Here is a concise summary of the text:\n\nThe text discusses database systems, specifically querying data using various languages. It introduces the concept of users and administrators accessing data, as seen in an example query that retrieves account balances for two customers. The authors highlight the importance of abstraction levels when manipulating data: physical level algorithms for efficient access, higher-level ease of use for human interaction. The text also mentions SQL (Structured Query Language) as a widely used query language studied in Chapter 4, with other languages covered in Chapter 5.", "152": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses the concept of database users and administrators, highlighting how they interact with databases. It uses an example query to demonstrate how a system would retrieve data from tables, in this case, finding account balances for specific customers. The passage also touches on database query languages, mentioning SQL as the most widely used language, which will be studied in later chapters. Additionally, it emphasizes the importance of abstraction levels when manipulating data, aiming to balance efficiency at the physical level with ease of use at higher levels of abstraction to facilitate human interaction with the system.", "62": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses the importance of understanding how to manipulate data in a database system. It highlights that there are various query languages used commercially or experimentally, with SQL being the most widely used language studied in Chapter 4. The text also emphasizes the significance of abstraction levels when manipulating data, moving from physical algorithms for efficient access at the lowest level to ease of use at higher levels. The ultimate goal is to enable humans to interact efficiently with the system through query languages like SQL, which is achieved by translating DML (Data Manipulation Language) queries into sequences of operations processed by the query processor component of the database system (studied in Chapters 13 and 14).", "153": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses database users and administrators, highlighting the importance of query languages in managing data. It mentions that SQL (Structured Query Language) is one of the most widely used query languages, which will be studied in Chapter 4. The text also emphasizes the levels of abstraction in manipulating data, from the physical level where algorithms ensure efficient access to data, to higher levels where ease of use and human interaction are prioritized. The goal is to enable humans to interact efficiently with the system.", "154": "Here is a concise summary of the text:\n\nThe chapter introduces the concept of database users and administrators, highlighting how they interact with databases. The example provided demonstrates how a query would retrieve data from tables to print out account balances for specific customers. The discussion also touches on different database query languages, including SQL, which will be studied in detail in Chapter 4. The text emphasizes that abstraction levels play a crucial role in both structuring and manipulating data, with the goal of allowing humans to interact efficiently with the system. This theme is closely tied to the concept of the query processor component, which translates DML queries into sequences of physical operations.", "155": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe passage discusses the concept of database systems, specifically highlighting the importance of query languages like SQL. It illustrates how a query would retrieve data from tables, showing that the system can find and print out account balances based on customer information. The text also emphasizes the different levels of abstraction in manipulating data, ranging from physical algorithms for efficient access to higher-level abstractions for ease of use. The ultimate goal is to allow humans to interact efficiently with the database system.", "156": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe passage discusses database systems, specifically the concept of query languages and levels of abstraction. It highlights that there are various query languages, with SQL being the most widely used, studied in Chapter 4. The passage also emphasizes the importance of manipulating data at different levels of abstraction: physical (efficient access), logical (ease of use), and conceptual (human interaction). The goal is to enable humans to interact efficiently with the database system, which involves translating Data Manipulation Language (DML) queries into sequences of algorithms, explored in Chapters 13 and 14.", "157": "Here is a concise summary of the text:\n\nThe primary goal of the query processor component in a database system is to enable efficient human interaction with the system. Application programs, written in languages such as Cobol, C++, or Java, are used to interact with the database and execute DML (Data Manipulation Language) queries. There are two ways for application programs to access the database: either through an Application Program Interface (API), which provides procedures for sending DML and DDL (Data Definition Language) statements to the database and retrieving results, or by utilizing standards such as ODBC (Open Database Connectivity) or JDBC (Java Database Connectivity).", "158": "Here is a concise summary of the text:\n\nThe goal of designing a database system is to make it easy for humans to interact with the system efficiently. The query processor component translates DML queries into physical-level actions, allowing application programs to access and manipulate data. Application programs are written in host languages like C, Cobol, or Java, and interact with the database using one of two methods: either by providing an API (such as ODBC for C or JDBC for Java) that sends DML statements and retrieves results, or by executing DML statements directly from the host language.", "159": "Here is a concise summary of the text:\n\nThe goal of designing a database system is to make it easy for humans to interact with the system. The query processor component translates DML queries into physical-level actions, enabling efficient interaction. Application programs, written in languages like C or Java, interact with the database by executing DML statements. There are two ways to do this: either through an application program interface (API) that allows sending DML and DDL statements and retrieving results, such as ODBC for C language or JDBC for Java; or by providing procedures that can be used to access the database.", "63": "Here is a concise summary of the provided text:\n\nThe ODBC (Open Database Connectivity) standard, defined by Microsoft for use with C language, and JDBC (Java Database Connectivity) standard provide interfaces for interacting with databases. These standards allow developers to embed database management language (DML) calls within their host language program using a preprocessor. The primary goal of a database system is to retrieve and store information, and users can be categorized as either database users or administrators. Four types of database users are identified, each with unique user interfaces: naive users who interact with the system in a straightforward way, sophisticated users who require more complex interactions, and query and report writers who focus on extracting specific data.", "29": "Here's a concise summary of the text:\n\nThe standardization of application programming interfaces (APIs) allows for seamless interaction between languages and databases. Specifically, ODBC (Open Database Connectivity) provides a standard for C language use, while JDBC (Java Database Connectivity) offers similar features for Java. The text also introduces key concepts in database systems, including user categories (users vs. administrators), transaction management (recovery from failure and concurrency control), and system structure. It highlights the importance of these components in ensuring data consistency and availability, particularly in larger-scale enterprise environments.", "160": "Here is a concise summary of the provided text:\n\nThe text discusses two application programming interfaces (APIs) - ODBC for C language and JDBC for Java language. Both APIs enable embedding Data Manipulation Language (DML) calls within host language programs, allowing developers to interact with databases. The process involves using a preprocessor to convert DML statements into normal procedure calls in the host language. Additionally, the text introduces the concept of database users and administrators, categorizing them into four types based on their expected interaction with the system. These categories include naive users, who are unsophisticated users interacting with the system through user interfaces designed for their specific needs.", "24": "Here is a concise summary of the text:\n\nThe chapter introduces two types of users: naive users and application programmers. Naive users interact with the system by invoking pre-written application programs, such as a bank teller using a \"transfer\" program or a user accessing their account balance online through a web form. These users typically use a forms interface to fill in fields or simply read reports generated from the database. In contrast, application programmers are computer professionals who write these application programs, designing and developing software that allows naive users to interact with the system effectively.", "161": "Here is a concise summary of the text:\n\nThe text discusses user interfaces and programming languages for interacting with databases. Naive users interact through forms, filling out fields or reading reports generated from the database. Application programmers can use various tools to develop user interfaces, including Rapid Application Development (RAD) tools that allow constructing forms and reports without writing code. Fourth-generation languages combine imperative control structures with data manipulation statements, facilitating form generation and data display on the screen. Sophisticated users, such as analysts, interact by forming queries in a database query language, which is processed by a query processor to generate instructions for the storage manager.\n\nKey concepts:\n\n* User interfaces: forms and reports\n* Programming languages:\n\t+ Fourth-generation languages (combining imperative control structures with data manipulation statements)\n\t+ Query languages (for sophisticated users)\n* RAD tools: enabling rapid development of user interfaces without writing code", "64": "Here is a concise summary of the text:\n\nThe user interface for naive users typically involves filling out forms or reading reports generated from a database. In contrast, application programmers develop interfaces using various tools and programming languages. Rapid Application Development (RAD) tools allow programmers to create forms and reports without writing code, while Fourth-Generation Languages (4GLs) combine imperative control structures with data manipulation statements to facilitate form generation and data display. Sophisticated users, on the other hand, interact with the system by forming requests in a database query language, submitting queries to a query processor that translates them into instructions understood by the storage manager. This includes analysts who explore data in the database using Online Analytical Processing (OLAP).", "162": "Here is a concise summary of the text:\n\nThe typical user interface for naive users involves filling out forms or reading reports generated from a database. In contrast, application programmers, including those using Rapid Application Development (RAD) tools and fourth-generation languages, can create more complex interfaces without writing traditional programs. These tools and languages often include features that facilitate form generation and data display. Sophisticated users, on the other hand, interact with the system by submitting queries in a database query language, which is then processed by a query processor to retrieve the desired information. This category includes analysts who explore data in the database for analysis purposes, as well as those using Online Analytical Processing (OLAP) tools.", "25": "Here is a concise summary of the text:\n\nThe query processor plays a crucial role in breaking down DML statements into instructions that the storage manager understands. Analysts submit queries to explore data in the database and can utilize OLAP tools to view summaries of data in various ways, such as by region, product, or combination of both. These tools also allow analysts to drill down for more detail or aggregate data at a higher level. Additionally, data mining tools help analysts find specific patterns in data. The chapter focuses on OLAP and data mining tools that cater to analysts' needs. In contrast, specialized users write unique database applications that don't fit into traditional frameworks, such as computer-aided design systems and knowledge management systems.", "26": "Here is a concise summary of the text:\n\nThe text discusses two categories of users interacting with databases: analysts and specialized users. Analysts submit queries to explore data in the database using tools such as Online Analytical Processing (OLAP) tools. These tools simplify tasks by allowing analysts to view summaries of data in different ways, drilling down into details or aggregating data at various levels. Data mining tools are another type of OLAP tool that helps analysts find patterns in data. Specialized users, on the other hand, write custom database applications that don't fit traditional data processing frameworks, such as computer-aided design systems and knowledge management systems.", "163": "Here is a concise summary of the text:\n\nThe query processor plays a crucial role in breaking down DML (Data Manipulation Language) statements into instructions that the storage manager understands, allowing analysts to explore data in the database. Online Analytical Processing (OLAP) tools simplify this process by enabling analysts to view summaries of data in different ways, such as by region, product, or combination thereof. OLAP tools also permit analysts to drill down for more detail or aggregate data for a broader overview. Additionally, Data Mining tools help analysts find specific patterns in data. The text highlights the importance of OLAP and Data Mining tools for analysts, and notes that these topics will be explored further in Chapter 22.", "65": "Here is a concise summary of the text:\n\nThe text discusses two types of users: general users who interact with databases using traditional data processing frameworks, and specialized users who develop applications that don't fit into this framework. Examples of these specialized applications include computer-aided design systems, knowledge systems, and environment modeling systems. The chapter also introduces the concept of a Database Administrator (DBA), who is responsible for central control over both the data and programs accessing it. A DBA's functions include defining the database schema, storage structure, and access methods, as well as modifying the schema and physical organization of the database.", "66": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses specialized users who develop unique database applications that don't fit traditional data-processing frameworks. These applications include computer-aided design systems, knowledge and expert systems, and environment-modeling systems. The chapter also introduces the concept of Database Management Systems (DBMS) and the role of a Database Administrator (DBA). A DBA is responsible for defining the database schema, storage structure, and access methods, as well as modifying the schema and physical organization as needed. This central control allows for efficient data management and access.", "164": "Here is a concise summary of the provided text, focusing on key concepts and their connections:\n\nThe text discusses two types of users: traditional data processing users and specialized users who write applications that don't fit into this framework. Specialized users include those working with computer-aided design systems, knowledge-based systems, and environment modeling systems. A Database Administrator (DBA) is responsible for central control over both the data and programs accessing it. The DBA's functions include defining the original database schema, specifying storage structure and access methods, and modifying the schema and physical organization as needed.", "37": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe chapter discusses specialized database applications that don't fit traditional data-processing frameworks. These applications include computer-aided design systems, knowledge-based systems, base and expert systems, and environment-modeling systems. The importance of having central control over both data and programs is highlighted, leading to the role of a Database Administrator (DBA). A DBA's functions include defining the database schema, storage structure, and access methods, as well as modifying the schema and physical organization.", "165": "Here is a concise summary of the text:\n\nThe key concepts in managing a database involve designing the schema and physical organization, modifying it to meet changing needs or improve performance, and controlling access through authorization. A Database Administrator (DBA) executes data definition language (DDL) statements to create the original schema, makes changes as needed, and grants different types of authorization to regulate user access. The DBA also performs routine maintenance tasks such as backing up the database, ensuring sufficient disk space, and monitoring job performance. Additionally, transaction management is crucial, as it ensures that multiple operations are treated as a single logical unit of work, preventing inconsistencies or losses in case of errors or system failures.", "27": "Here's a concise summary of the text, focusing on key concepts and their connections:\n\nThe history of database systems dates back to the early 20th century, when punched cards were used for data processing tasks like census data recording. Automation of data processing tasks predates computers. Over time, techniques for data storage and processing have evolved, including magnetic tapes in the 1950s-60s and computerized systems that store data on disk storage. Key concepts include:\n\n1. **Concurrency control**: Managing interactions among concurrent transactions to ensure database consistency.\n2. **Durability**: Ensuring data persists despite system failures.\n3. **Atomicity**: Ensuring all or none of a transaction's operations occur, preserving the database's consistency.\n4. **Consistency**: Preserving the database's integrity by ensuring each transaction maintains consistency.\n5. **Transactions**: Collections of operations that perform a single logical function in a database application.\n\nThese concepts are interconnected: transactions must be both atomic and consistent, and durability ensures data persists despite system failures. The text also highlights the importance of proper transaction definition to preserve database consistency, as well as the need for concurrency control to manage interactions among concurrent transactions.", "67": "Here is a concise summary of the text:\n\nThe concept of transactions in databases is crucial for ensuring data consistency and integrity. A transaction is a collection of operations that performs a single logical function, such as transferring funds from one account to another. Key characteristics of transactions include atomicity (either all or none of the operations occur), consistency (the database remains consistent before, during, and after the transaction), and durability (changes persist even in case of system failure). These properties ensure that database consistency constraints are not violated, and programmers must define transactions carefully to preserve data integrity.", "166": "Here is a concise summary of the text:\n\nIn a database system, durability and atomicity are crucial concepts that ensure transactions persist despite possible system failures. A transaction is a collection of operations that perform a single logical function, and it must not violate any database consistency constraints. This means that if the database was consistent when a transaction started, it must remain consistent upon successful completion. However, temporary inconsistencies may be necessary during transaction execution, which can lead to difficulties if a failure occurs. It is the programmer's responsibility to define transactions properly to preserve database consistency, such as in the example of transferring funds between accounts, where two separate programs are required to debit and credit the correct amounts.", "167": "Here is a concise summary of the text:\n\nA transaction in a database is a set of operations that performs a single logical function. It requires both atomicity and consistency, meaning it must not violate any database constraints and maintain consistency throughout its execution. Durability ensures that even if the system fails, the transaction's effects persist. Transactions may temporarily allow inconsistencies during execution, but it's crucial to define them properly to preserve database consistency. For instance, a fund transfer transaction could be broken down into two separate programs: one debiting account A and another crediting account B.", "168": "Here is a concise summary of the text:\n\nA transaction in a database application is a collection of operations that performs a single logical function. For a transaction to be considered durable, it must persist despite the possibility of system failure. This requires that transactions maintain atomicity and consistency, meaning that if the database was consistent when the transaction started, it must remain consistent upon successful termination. While temporary inconsistencies may arise during transaction execution, it is the programmer's responsibility to define transactions that preserve database consistency. For example, a funds transfer transaction might be composed of two separate programs: one that debits account A and another that credits account B, ensuring consistency throughout.", "169": "Here is a concise summary of the text:\n\nIn a database management system, transactions are critical for ensuring consistency and integrity. A transaction should preserve the consistency of the database by transforming it from one consistent state to another. However, simply executing separate programs for debit and credit operations does not constitute a transaction. The responsibility lies with the transaction-management component to ensure atomicity (ensuring that the transaction is treated as a single, indivisible unit) and durability (preventing partial effects of the transaction). While transactions typically complete successfully without failures, unexpected system crashes or errors can occur, requiring failure recovery mechanisms to restore the database to its pre-transaction state, ensuring that failed transactions have no effect on the database's consistency.", "170": "Here's a concise summary of the text:\n\nTo maintain data consistency and integrity, a database system must perform failure recovery by restoring the database to its previous state in case of system failures. Additionally, concurrency control is essential when multiple transactions update the database simultaneously. The database system must detect and prevent inconsistencies by controlling transaction interactions. Not all databases have these features, as some are designed for small personal computers and may only allow single-user access or lack backup and recovery capabilities. These limitations enable smaller data managers with fewer resource requirements, but are inadequate for larger-scale enterprises.", "171": "Here is a concise summary of the text:\n\nA database system must ensure the consistency and integrity of data in various scenarios, including transaction failures, concurrency, and multiple user access. To achieve this, the system performs failure recovery by restoring the database to its previous state before a transaction failed. Additionally, when multiple transactions update the database concurrently, a concurrency control manager is responsible for ensuring data consistency. While small personal computers may not require all these features, enterprise-level databases need to handle these complexities to maintain data integrity and consistency. The text highlights the importance of modular design in database systems, dividing responsibilities among different modules to manage these challenges effectively.", "68": "Here's a concise summary of the text:\n\nA database system must be able to recover from failures, such as transactional errors or system crashes, and restore the database to its previous state. This process is called failure recovery. Additionally, when multiple transactions update the database concurrently, consistency must be maintained through concurrency control. A good database system should be able to handle these complexities and ensure data integrity. However, smaller personal computers may have limited features, such as single-user access or no backup and recovery capabilities, which reduces resource requirements but is insufficient for larger-scale enterprises. The text also touches on the modular structure of a database system, with separate modules handling different responsibilities such as failure recovery, concurrency control, and data management.", "172": "Here is a concise summary of the text:\n\nA database system must ensure data consistency and integrity by recovering from failures, detecting system crashes, and restoring the database to its previous state. When multiple transactions update the database concurrently, concurrency control managers are responsible for maintaining data consistency. Database systems designed for small personal computers may not have all these features, instead prioritizing simplicity and resource efficiency. However, this approach is inadequate for larger-scale enterprise databases that require more robust features. The text also introduces the concept of modularization in a database system, where each module handles specific responsibilities, setting the stage for further discussion on database system structure.", "173": "Here is a concise summary of the text:\n\nA database system must ensure consistency and recover from failures, which involves detecting system failures and restoring the database to its previous state. When multiple transactions update the database concurrently, concurrency control is necessary to maintain data consistency. While small personal computer databases may not have these features due to resource constraints, medium-to-large-scale enterprise databases require more advanced capabilities. A database system structure consists of modules that handle different responsibilities, including failure recovery, concurrency control, and other tasks.", "69": "Here is a concise summary of the text:\n\nThe approach described is suitable for small personal databases, but not for medium-to-large-scale enterprises. A more comprehensive database system structure is necessary for larger systems, comprising modules handling different responsibilities. The two main components are the storage manager and query processor. The storage manager is crucial due to the massive size of corporate databases (hundreds of gigabytes to terabytes), which exceed the capacity of computer memory. As a result, data is stored on disks, with movement between disk storage and main memory being slow compared to the central processing unit's speed.", "30": "Here is a concise summary of the text:\n\nThe approach to database systems described earlier is sufficient for small, personal databases, but not suitable for medium-to-large-scale enterprises. To accommodate larger datasets, a database system is structured into modules, including the storage manager and query processor components. The storage manager is responsible for managing large amounts of data stored on disk, using techniques such as buffering to move data between disk and main memory efficiently. It implements various data structures, including data files, data dictionaries, and indices, to support fast access and retrieval of data. The query processor component translates high-level queries into low-level instructions that can be executed by the database system, and includes interpreters for DDL (data definition language) statements and compilers for DML (data manipulation language) statements.", "174": "Here is a concise summary of the text:\n\nThe traditional approach to building a database system may be sufficient for small personal databases, but it falls short when dealing with medium- to large-scale enterprises. A more effective approach is to divide a database system into modules, each responsible for a specific function. Two key components are the storage manager and query processor. The storage manager is crucial due to the massive amounts of data involved, which can range from hundreds of gigabytes to terabytes. Since main memory cannot store this amount of information, data is stored on disks, requiring efficient movement between disk storage and main memory.", "175": "Here is a concise summary of the text:\n\nThe approach for managing small personal databases is not sufficient for medium-to-large-scale enterprises. A comprehensive database system should be structured into modules, including storage manager and query processor components. The storage manager is crucial as large corporate databases can range from hundreds of gigabytes to terabytes in size. Due to limited main memory capacity, data are stored on disks and moved between disk and main memory as needed. This movement is slow compared to the central processing unit's speed, making efficient database system management essential.", "176": "Here is a concise summary of the text:\n\nThe approach to database systems described is suitable for small personal databases but not sufficient for larger-scale enterprises. A comprehensive database system structure consists of modules that handle different responsibilities, including storage management and query processing. The storage manager plays a crucial role due to the massive amounts of data stored in corporate databases, which can range from hundreds of gigabytes to terabytes. Since main memory is insufficient to store this volume of data, it is stored on disks, with data being transferred between disk and memory as needed. This highlights the importance of optimizing data movement between storage and processing components to ensure efficient database operations.", "177": "Here's a concise summary of the text:\n\nThe approach described is suitable for small personal databases but inadequate for medium-to-large-scale enterprises. A database system consists of modules that handle various responsibilities, including storage management and query processing. The storage manager is crucial due to the massive amounts of data stored in corporate databases (hundreds of gigabytes to terabytes). Since main memory cannot store this information, data are stored on disks, requiring efficient movement between disk storage and main memory. This slow process highlights the importance of designing a database system that optimizes data transfer to minimize latency and ensure smooth operation.", "178": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe database system aims to efficiently manage information stored on disks while minimizing data movement between disk storage and main memory. To achieve this, the query processor simplifies and facilitates access to data through high-level views that abstract away physical implementation details. The storage manager, a program module, acts as an interface between application programs and queries, translating logical-level updates and queries into efficient physical-level operations. This translation is crucial for quick processing of updates and queries, which is essential for the system's overall performance.", "179": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe database system's primary goal is to efficiently manage and retrieve data while minimizing the need for slow disk-to-memory data transfers. To achieve this, the query processor simplifies access to data through high-level views, abstracting away physical implementation details. The storage manager plays a crucial role in translating non-procedural updates and queries into efficient physical operations. This module provides an interface between application programs and low-level database data, interacting with the file manager to store raw data on disk using the file system. Overall, the database system's structure is designed to balance the need for quick processing of updates and queries with the importance of minimizing disk-to-memory data transfers.", "13": "Here is a concise summary of the text:\n\nThe automation of data processing tasks dates back to the early 20th century, with punched cards being used for record-keeping. The development of magnetic tapes in the 1950s and early 1960s enabled the automation of tasks such as payroll processing. However, these early systems were limited by their sequential access nature, requiring programs to process data in a particular order.\n\nThe introduction of hard disks in the late 1960s revolutionized data processing, allowing for direct access to data and freeing it from sequentiality. This led to the development of network and hierarchical databases, which allowed for more complex data structures and querying.\n\nThe relational model, defined by Edgar Codd in 1970, introduced a non-procedural way of querying data, leading to the creation of relational databases. The simplicity of this model and its ability to hide implementation details from programmers made it an attractive option. This led to the development of commercial relational database systems such as SQL/DS, DB2, Oracle, Ingres, and DEC RDB.\n\nThe key concepts connected in this summary include:\n\n* Automation of data processing tasks\n* Early storage technologies (punched cards, magnetic tapes)\n* Impact of hard disk technology on data processing\n* Introduction of the relational model and relational databases", "180": "Here is a concise summary of the text:\n\nThe key challenge in a database system is minimizing the need to move data between disk storage and main memory due to speed differences. To achieve this, the query processor helps simplify access to data by providing high-level views that abstract away physical implementation details. The storage manager plays a crucial role in translating logical updates and queries into efficient physical operations, serving as an interface between application programs and low-level data stored on disk.", "70": "Here is a concise summary of the text:\n\nThe Storage Manager is a crucial component of a database system that interacts with the File Manager to store and manage low-level data on disk storage. It translates DML (Data Manipulation Language) statements into file-system commands, ensuring data consistency and integrity through its components: Authorization and Integrity Manager, Transaction Manager, File Manager, and Buffer Manager. The Authorization and Integrity Manager checks user access authority and data integrity constraints, while the Transaction Manager ensures database consistency despite system failures or concurrent transactions. The File Manager manages disk storage allocation and data structures, and the Buffer Manager fetches data from disk to main memory, enabling efficient handling of large datasets.", "71": "Here is a concise summary of the text:\n\nThe Storage Manager is a crucial component of a database system that handles the interaction between the database and the underlying file system. Its primary responsibilities include storing, retrieving, and updating data in the database by translating DML statements into low-level file system commands. The Storage Manager consists of several components: the Authorization and Integrity Manager ensures data integrity and user access; the Transaction Manager manages concurrent transactions to maintain consistency; the File Manager manages disk storage allocation and data structures; and the Buffer Manager fetches data from disk to main memory, deciding what data to cache. This enables the database system to handle large data sizes effectively.", "38": "Here is a concise summary of the text:\n\nThe buffer manager plays a crucial role in a database system by managing data transfer between disk storage and main memory, allowing for efficient handling of large data sizes. The storage manager implements several key components, including data files (storing the database), a data dictionary (containing metadata about the database's structure), and indices (enabling fast access to specific data). Additionally, the query processor is responsible for executing queries, comprising two main components: the DDL interpreter, which interprets Data Definition Language statements and updates the data dictionary, and the DML compiler, which translates queries into executable plans.", "181": "Here is a concise summary of the text:\n\nThe buffer manager plays a crucial role in a database system, allowing it to handle large data sizes by caching data in main memory. The storage manager implements various data structures, including data files, data dictionaries, and indices, which enable fast access to specific data items. The query processor consists of two components: the DDL interpreter, which interprets schema definitions, and the DML compiler, which translates SQL statements into executable plans for the query evaluation engine. These components work together to facilitate efficient data retrieval and manipulation in a database system.", "182": "Here is a concise summary of the text:\n\nThe buffer manager plays a crucial role in a database system, enabling it to handle large data sizes by fetching and caching data from disk storage to main memory. The storage manager implements several key components: data files storing the database itself, a data dictionary keeping metadata about the database's structure (schema), and indices providing fast access to specific data items. Additionally, the query processor is composed of two primary components: a DDL interpreter that interprets Data Definition Language statements and records definitions in the data dictionary, and a DML compiler that translates Data Manipulation Language statements into an evaluation plan for the query engine.", "72": "Here is a concise summary of the text:\n\nThe text describes the components and connections involved in a database system's architecture. The DML (Data Manipulation Language) compiler translates high-level query language statements into low-level instructions that can be executed by the query evaluation engine. This engine executes the instructions to produce the desired result. The compiler also optimizes queries by selecting the most cost-effective plan from multiple alternatives. Additionally, the text highlights the importance of client-server architecture, where users access a database system through a network, and explains how applications are partitioned into two or three parts, including the use of application program interfaces (APIs) like ODBC and JDBC for interaction between clients and servers.", "20": "Here's a concise summary of the text:\n\nThe main components of a Database Management System (DBMS) are the compiler, query evaluation engine, and storage manager subsystem. The compiler translates Data Manipulation Language (DML) statements into low-level instructions that the query evaluation engine understands. The query evaluation engine executes these instructions to retrieve or modify data stored in the database. The storage manager subsystem provides the interface between the physical data storage and the application programs or queries submitted to the system. Additionally, the text discusses database architecture, distinguishing between client machines (where remote users work) and server machines (where the DBMS runs). It also introduces various concepts such as database systems, file systems, consistency constraints, data models, and query languages like DML, which are essential for understanding how a DBMS works.", "183": "Here is a concise summary of the text:\n\nThe text describes the components of a database system architecture, focusing on the compiler and query evaluation engine. The DML (Data Manipulation Language) compiler translates queries into low-level instructions that the query evaluation engine can execute. The compiler also performs query optimization by selecting the most efficient evaluation plan from multiple alternatives. The query evaluation engine then executes these instructions to produce the desired result. Additionally, the text discusses the concept of client-server architecture, where database applications are partitioned between client machines (where users work) and server machines (where the database system runs). This is depicted in Figure 1.5, which shows a two-tier architecture with a component at the client machine that invokes database functionality at the server machine using query language statements and API standards like ODBC and JDBC.", "184": "Here is a concise summary of the text:\n\nThe text describes the architecture of a database system, focusing on two main components: the DML compiler and the query evaluation engine. The DML compiler translates high-level DML statements into low-level instructions that the query evaluation engine can execute. This translation process also involves query optimization, where the compiler selects the most efficient evaluation plan from multiple alternatives. The query evaluation engine then executes these low-level instructions to produce the desired results. Additionally, the text discusses application architectures, highlighting the distinction between client machines and server machines, as well as two-tier architecture, which partitions applications into a client-side component that invokes database functionality through query language statements at the server side.", "73": "Here is a concise summary of the text:\n\nThe text describes two types of database application architectures: the \"two-tier\" architecture and the \"three-tier\" architecture. In the two-tier approach, a client machine invokes database system functionality at a server machine using standards like ODBC or JDBC. In contrast, three-tier applications have a client machine that communicates with an application server, which in turn accesses data from a database system. The business logic of the application is embedded in the application server rather than being distributed across multiple clients. Three-tier architectures are more suitable for large-scale and web-based applications.\n\nNote: The provided text seems to be interrupted by unrelated information about the history of database systems, but I have excluded that part from my summary as it is not directly related to the main topic of the two types of application architectures.", "74": "Here is a concise summary of the text:\n\nThe application is partitioned into two parts: a client-side component that interacts with the server using API standards like ODBC or JDBC, and a server-side component that accesses the database system. In contrast, three-tier architecture separates the client, application server, and database system, with the client only communicating with the application server through forms interfaces. The business logic of the application is embedded in the application server, making it more suitable for large-scale applications and web-based systems.", "185": "Here is a concise summary of the text:\n\nThe automation of data processing tasks predates computers, with punched cards being used in the early 20th century to record US census data and mechanical systems tabulating results. Later, punched cards were used to enter data into computers. Over time, techniques for data storage and processing evolved: magnetic tapes were developed in the 1950s and 1960s for storing data, allowing tasks like payroll automation. Processing involved reading data from one or more tapes.", "186": "Here is a concise summary of the text:\n\nThe automation of data processing tasks predates computer technology, with punched cards being used to record US census data in the early 20th century. Mechanical systems were also employed to process this data. The development of computers led to the use of punched cards as a means of entering data into machines. Over time, techniques for storing and processing data have evolved, including the introduction of magnetic tapes for data storage in the 1950s and 1960s. This evolution has enabled automation of tasks such as payroll processing, with data stored on tapes and processed by reading from one or more sources.", "187": "Here is a concise summary of the text:\n\nThe automation of data processing tasks predates computers, with punched cards being used to record US census data in the early 20th century. Mechanical systems were also used to process data. Later, punched cards became a means of entering data into computers. Over time, techniques for data storage and processing evolved, including the development of magnetic tapes for storing data in the 1950s and early 1960s. This allowed for the automation of tasks such as payroll processing, with data being read from multiple tapes to perform calculations.", "188": "Here is a concise summary of the text:\n\nThe automation of data processing tasks began before computers existed. In the early 20th century, punched cards were used to record census data in the US, with mechanical systems processing the information. Later, punched cards became a means of entering data into computers. Over time, techniques for data storage and processing evolved, including the development of magnetic tapes for data storage in the 1950s and early 1960s. Data processing tasks such as payroll automation emerged, using tapes to store and process data.", "189": "Here is a concise summary of the text:\n\nThe automation of data processing tasks predates computers, with punched cards invented by Hollerith used to record US census data in the early 20th century. Mechanical systems were used to process and tabulate results. Later, punched cards were used as an input method for computers. Techniques for data storage and processing have evolved over time, including the development of magnetic tapes for data storage in the 1950s and early 1960s. This led to the automation of tasks such as payroll processing, with data stored on tapes and processed by reading from one or more tapes.", "190": "Here is a concise summary of the text:\n\nThe automation of data processing tasks predates computers, with punched cards being used in the early 20th century to record US census data and mechanical systems tabulating results. Later, punched cards were widely used to enter data into computers. Over time, techniques for data storage and processing have evolved, including the development of magnetic tapes for data storage in the 1950s and early 1960s. This led to automation of tasks such as payroll processing, with data stored on tapes and processed by reading from one or more tapes.\n\nThe key concepts highlighted are:\n\n* The early use of punched cards for data recording and processing\n* The evolution of data storage techniques, including the introduction of magnetic tapes\n* The automation of data processing tasks, including payroll processing\n\nThese concepts demonstrate how data processing has been automated over time, laying the foundation for modern database systems.", "191": "Here is a concise summary of the text:\n\nThe automation of data processing tasks began before the advent of computers, using punched cards to record census data in the early 20th century. Mechanical systems were also used to process and tabulate results. Later, punched cards became a means of entering data into computers. Over time, techniques for data storage and processing evolved: magnetic tapes were developed in the 1950s and early 1960s for storing data, allowing tasks like payroll automation. This marked the beginning of a series of innovations that would eventually lead to modern database systems.", "192": "Here is a concise summary of the text:\n\nThe automation of data processing tasks began before computers existed, using punched cards to record census data in the early 20th century. Mechanical systems were also used to process this data. Later, punched cards became a means of entering data into computers. Over time, techniques for data storage and processing evolved: magnetic tapes emerged in the 1950s and 1960s for storing data, which was then processed by reading from one or more tapes. This marked the beginning of automated data processing tasks, including payroll automation.", "193": "Here is a concise summary of the text:\n\nThe automation of data processing tasks predates computers, with punched cards invented by Hollerith in the early 20th century being used to record US census data and mechanical systems tabulating results. Later, punched cards were used to enter data into computers. The evolution of techniques for data storage and processing continues, with major advancements including the development of magnetic tapes for data storage in the 1950s and early 1960s. These developments enabled tasks like payroll automation, where data was stored on tapes and processed by reading from one or more tapes.", "194": "Here is a concise summary of the text:\n\nThe automation of data processing tasks began long before computers existed. Punched cards, invented by Hollerith, were used to record US census data in the early 20th century and mechanical systems processed the data. Later, punched cards became a means of entering data into computers. Techniques for data storage and processing evolved over time, including the development of magnetic tapes for data storage in the 1950s and early 1960s. This allowed for automation of tasks like payroll processing, with data stored on tapes and processed by reading from one or more tapes.", "195": "Here is a concise summary of the text:\n\nThe automation of data processing tasks predates computers by several decades. Punched cards, invented by Hollerith, were used to record US census data in the early 20th century and later became a means of entering data into computers. Over time, techniques for data storage and processing have evolved, including the development of magnetic tapes for storing data in the 1950s and early 1960s. This era saw the automation of tasks such as payroll processing, with data stored on tapes and processed by reading from one or more tapes. These early developments laid the foundation for the evolution of database systems, which will be explored in the following text.", "196": "Here is a concise summary of the text:\n\nThe automation of data processing tasks began before the advent of computers, with punched cards being used to record US census data in the early 20th century. Mechanical systems were also used to process data during this time. The use of punched cards later evolved into entering data into computers. Over the years, techniques for storing and processing data have progressed: magnetic tapes were developed in the 1950s and 1960s for data storage, allowing tasks like payroll automation, and subsequent advancements enabled reading and processing data from multiple sources.\n\nLet me know if you'd like me to highlight any specific connections or key concepts!", "197": "Here is a concise summary of the text:\n\nIn the 1950s and early 1960s, data processing evolved to use magnetic tapes for storage, automating tasks like payroll processing. Data was stored on tapes and processed by reading from one or more tapes, with writing done to new tapes. Input came from punched card decks, while output went to printers. For example, salary raises were processed by entering changes on cards, matching the sorted order of a master tape containing salary details. The raised salaries were then written to a new tape, becoming the new master tape. This early system was limited by sequential reading and writing, with large data sizes that exceeded main memory capacity.", "198": "Here is a concise summary of the text:\n\nThe development of magnetic tapes for data storage in the 1950s and early 1960s marked a significant milestone in the evolution of computing. This era saw the automation of data processing tasks, such as payroll management, with data stored on tapes. Processing involved reading data from one or more tapes, writing new data to a new tape, and input/output operations via punched card decks and printers. The need for sorted records and sequential access highlights the limitations of this technology, where data sizes were much larger than main memory.", "199": "Here is a concise summary of the text:\n\nIn the 1950s and early 1960s, data processing and storage evolved with the development of magnetic tapes. Data was stored on these tapes and processed through automated tasks such as payroll processing. The processing involved reading data from one or more tapes and writing data to new tapes. Input came from punched card decks, while output went to printers. For example, salary raises were processed by adding raise amounts to master salary details on a tape, creating a new tape with updated salaries. This era's limitations included the sequential nature of tape reading and larger data sizes compared to main memory.", "39": "Here is a concise summary of the text:\n\nIn the 1950s and early 1960s, data processing evolved to include magnetic tapes for data storage and automated tasks such as payroll. Data was stored on tapes and processed by reading from one or more tapes and writing to a new tape. Additionally, data could be input from punched card decks and output to printers. For example, salary raises were processed by entering the raises on cards, reading the deck in sync with a master tape, adding the raises to the salaries, and writing the results to a new tape. This sequential access and larger data sizes posed challenges compared to main memory.", "75": "Here is a concise summary of the text:\n\nIn the early days of computing, data processing programs had to process data sequentially due to the limitations of tapes and card decks. This led to a rigid order of processing data. However, with the advent of hard disks in the late 1960s, direct access to data became possible, freeing data from sequentiality. This revolutionized data processing, enabling the creation of network and hierarchical databases that allowed for complex data structures like lists and trees. The relational model, defined by Codd in 1970, further simplified data management by allowing non-procedural querying and hiding implementation details from programmers.", "200": "Here is a concise summary of the text:\n\nThe development of data processing systems evolved significantly with the introduction of hard disks in the late 1960s. Prior to this, data processing was limited by the sequential nature of tape and card decks, forcing programs to process data in a specific order. The advent of direct-access hard disks revolutionized data processing, allowing for rapid access to any location on the disk. This enabled the creation of network and hierarchical databases, as well as the concept of relational databases, which allowed programmers to construct and manipulate complex data structures such as lists and trees. The simplicity and flexibility of the relational model, defined by Codd in 1970, further solidified its importance in shaping the future of data processing.", "201": "Here is a concise summary of the text:\n\nThe evolution of data processing was driven by advancements in storage technology. Initially, tapes and card decks required sequential access to data, forcing programs to process data in a specific order. However, with the introduction of hard disks in the late 1960s, direct access to data became possible, freeing it from the constraints of sequentiality. This led to the development of network and hierarchical databases that allowed for complex data structures like lists and trees to be stored and manipulated on disk. The relational model, proposed by Edgar Codd in 1970, revolutionized database management by introducing a simple and intuitive way to query data, hiding implementation details from programmers.", "202": "Here is a concise summary of the text:\n\nIn the early days of computing, data processing was hindered by sequential access to data stored on tapes or card decks, requiring programs to process data in a specific order. However, the advent of hard disks in the late 1960s revolutionized data processing by allowing direct access to data, freeing it from sequentiality constraints. This enabled the creation of network and hierarchical databases that could store complex data structures like lists and trees. The relational model, introduced by Codd in 1970, further transformed data processing by providing a simple way to query data non-procedurally, leading to the development of relational databases that hid implementation details from programmers.", "21": "Here is a concise summary of the text:\n\nThe relational model, introduced by Edgar F. Codd, revolutionized data querying with its simplicity and ability to hide implementation details from programmers. This led to the development of relational databases, which initially faced performance disadvantages compared to existing network and hierarchical databases. However, IBM's System R project in the 1980s overcame these limitations, paving the way for the first commercial relational database products such as SQL/DS, DB2, Oracle, Ingres, and DEC RDB. The success of System R and subsequent commercial products like IBM DB2 and Oracle led to the widespread adoption of relational databases, marking a significant milestone in the history of data management.", "203": "Here is a concise summary of the text:\n\nThe relational model, introduced by Codd in the 1970s, revolutionized data querying with non-procedural methods. Although academically interesting, it wasn't initially adopted due to perceived performance disadvantages compared to existing network and hierarchical databases. However, IBM's System R project, developed in the 1980s, tackled this issue and created an efficient relational database system. This breakthrough led to the development of the first commercial relational database products, such as SQL/DS, DB2, Oracle, Ingres, and DEC RDB, which ultimately replaced traditional network and hierarchical databases.", "204": "Here is a concise summary of the text:\n\nThe development of relational database prototypes led to IBM's first relational database product, SQL/DS. This innovation enabled efficient processing of declarative queries and eventually replaced network and hierarchical databases in popularity. Relational databases simplified programming by automating low-level tasks, allowing programmers to focus on logical levels. The 1980s saw the dominance of the relational model, followed by research on parallel and distributed databases as well as early work on object-oriented databases. By the early 1990s, SQL language development focused primarily on decision support systems.", "205": "Here is a concise summary of the text:\n\nThe development of relational database prototypes, such as SQL/DS, led to the creation of commercial relational database systems like DB2, Oracle, and Ingres. These systems improved query processing efficiency and eventually surpassed network and hierarchical databases in performance. Relational databases simplified programming by automating low-level tasks, freeing developers to focus on logical queries. This dominance of the relational model persisted throughout the 1980s, with research also underway on parallel and distributed databases as well as early work on object-oriented databases.", "40": "Here is a concise summary of the text:\n\nThe development of relational database systems, such as SQL/DS, led to significant advancements in query processing efficiency and user-friendliness. By the early 1980s, relational databases became competitive with network and hierarchical databases in terms of performance, eventually replacing them due to their ease of use. In contrast to traditional databases, relational databases abstracted away low-level implementation details, allowing programmers to focus on logical queries rather than manual optimization. The relational model dominated data models from the 1980s onwards, driving research into parallel and distributed databases as well as object-oriented databases.", "206": "Here is a concise summary of the text:\n\nThe development of relational database systems, such as SQL/DS, led to the creation of commercial products like IBM DB2, Oracle, and others. These systems improved query processing efficiency, becoming competitive with network and hierarchical databases in performance by the early 1980s. Relational databases ultimately replaced these older models due to their ease of use, abstracting away low-level implementation details and allowing programmers to work at a logical level. This led to the relational model's dominance throughout the 1980s. Research continued on parallel and distributed databases, as well as object-oriented databases, during this period. In the early 1990s, SQL was designed primarily for decision support systems, marking another significant milestone in the evolution of relational databases.", "207": "Here is a concise summary of the text:\n\nThe development of relational database systems, starting with IBM's SQL/DS prototype, led to significant advancements in processing declarative queries efficiently. By the early 1980s, relational databases had become competitive with network and hierarchical databases in terms of performance. Relational databases offered ease of use, automating low-level tasks for programmers and allowing them to focus on logical programming. This dominance continued throughout the 1980s. The decade also saw research into parallel and distributed databases, as well as initial work on object-oriented databases. In the early 1990s, the SQL language was designed specifically for decision-making purposes, marking a key milestone in the evolution of relational database systems.", "208": "Here is a concise summary of the text:\n\nThe development of relational database prototypes, such as IBM's SQL/DS, led to the creation of commercial relational database systems like DB2, Oracle, and Ingres. These systems improved query processing efficiency, eventually surpassing network and hierarchical databases in performance. Relational databases were more user-friendly, freeing programmers from low-level implementation details and procedural coding, allowing them to focus on logical design. The relational model dominated data models in the 1980s, with parallel and distributed database research also emerging. In the early 1990s, the SQL language was designed primarily for decision-making applications, further solidifying the relational database's position as a leading technology.", "76": "Here is a concise summary of the text:\n\nThe development of relational databases led to the creation of IBM's SQL/DS product, which in turn influenced the emergence of other relational database systems like DB2, Oracle, and Ingres. By the early 1980s, relational databases had surpassed network and hierarchical databases in terms of performance, ease of use, and efficiency. This shift allowed programmers to focus on logical levels rather than low-level implementation details, leading to a significant reduction in programming effort. The relational model dominated data models throughout the 1980s, with research also underway on parallel and distributed databases, as well as object-oriented databases. In the early 1990s, SQL language was designed primarily for decision support systems.", "209": "Here is a concise summary of the text:\n\nThe development of relational database systems, including IBM's SQL/DS, led to significant advancements in efficient processing of declarative queries. By the early 1980s, relational databases had become competitive with network and hierarchical databases in terms of performance, eventually replacing them due to their ease of use and ability to abstract away low-level implementation details from programmers. The relational model dominated data models by the 1980s, paving the way for research into parallel and distributed databases as well as object-oriented databases.", "19": "Here is a concise summary of the text:\n\nThe relational model dominated the data modeling landscape in the 1980s, with research on parallel and distributed databases also underway. The early 1990s saw a shift towards decision support applications, which drove growth in data analysis tools and parallel database products. Database vendors began to incorporate object-relational support into their systems. By the late 1990s, the widespread adoption of the World Wide Web led to increased demands on database systems for high transaction processing rates, reliability, and 24/7 availability. Additionally, databases needed to support web interfaces to data.", "28": "Here is a concise summary of the text:\n\nThe relational model dominated data modeling in the 1980s, with research also focusing on parallel and distributed databases. In the early 1990s, decision support applications emerged as a major area for databases, driven by query-intensive needs. This led to growth in tools for analyzing large datasets and the introduction of parallel database products. Database vendors began adding object-relational support to their systems. By the late 1990s, the World Wide Web's explosive growth transformed databases, requiring them to support high transaction processing rates, reliability, and 24/7 availability. Additionally, databases had to accommodate web interfaces to data. Throughout this period, database management systems (DBMS) consisted of interconnected data and programs designed to manage and query that data.", "77": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nA Database Management System (DBMS) consists of interconnected data and programs that access that data. The primary goal of a DBMS is to provide an efficient and convenient environment for retrieving and storing information. DBMSs manage large bodies of data, involving both structure definition and manipulation mechanisms. Additionally, they must ensure the safety of stored information against system crashes or unauthorized access. Key components of a DBMS include the Storage Manager, which interfaces with low-level data storage, and Database Languages (Data Definition Language, Data Manipulation Language, and Query Language) that allow users to interact with the database. The text also touches on various architectures, such as two-tier and three-tier systems, where the front-end interacts with a back-end database or application server.", "210": "Here is a concise summary of the text:\n\nA database system must provide mechanisms for manipulating information, ensuring its safety and security from unauthorized access or system crashes. A key purpose of a database is to offer users an abstract view of the data, hiding underlying storage and maintenance details. The structure of a database relies on a data model, which describes data, relationships, semantics, and constraints. The entity-relationship (E-R) model is a widely used graphical representation, while other models include relational, object-oriented, object-relational, and semistructured data models. The overall design of the database, known as the schema, is specified using a data-definition language (DDL).", "211": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nA database system must provide mechanisms for managing information, ensuring its safety from crashes or unauthorized access, and avoiding anomalous results when sharing data among users. The system also provides an abstract view of the data, hiding storage and maintenance details. At its core is a data model, such as the Entity-Relationship (E-R) model, which describes data relationships, semantics, and constraints. The database schema, specified using a Data Definition Language (DDL), outlines the overall design of the system.", "212": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text introduces the concept of database management systems (DBMS) and their interaction with applications. A DBMS, like ##m, compiles and executes Data Definition Language (DDL) and Data Manipulation Language (DML) statements. The Storage Manager Subsystem provides an interface between low-level data stored in the database and application programs or queries submitted to the system. Database systems are typically divided into front-end and back-end parts, with different architectures such as two-tier and three-tier models. The text also discusses key concepts such as data abstraction, consistency constraints, physical data independence, data models (entity-relationship, relational, object-oriented, and object-relational), database languages (DDL, DML, and query language), and metadata.", "78": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses the components and architecture of a Database Management System (DBMS). The DBMS compiles and executes Data Definition Language (DDL) and Data Manipulation Language (DML) statements. The Storage Manager Subsystem provides an interface between low-level data stored in the database and application programs or queries submitted to the system. Database applications typically have a front-end part running at client machines and a back-end part, which can be further divided into Application Server and Database Server in three-tier architectures. Key concepts include database systems, applications, file systems, consistency constraints, data views, abstraction, and data models (entity-relationship, relational, object-oriented, and object-relational). The text also touches on database languages (data definition, manipulation, and query), data dictionaries, metadata, and physical schema versus logical schema.", "79": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe database management system (DBMS) ##m compiles and executes DDL (Data Definition Language) and DML (Data Manipulation Language) statements. The Storage Manager Subsystem provides an interface between low-level data stored in the database and application programs or queries submitted to the system. DBMSs typically consist of a front-end (client-side) and back-end (server-side), with two-tier architectures having the front-end directly communicating with the back-end, while three-tier architectures have the back-end split into an Application Server and Database Server. The text also introduces key concepts such as data models, database languages, and metadata, highlighting the importance of data abstraction, consistency constraints, and physical data independence in DBMS design.", "213": "Here's a concise summary of the text:\n\nThe text discusses various aspects of Database Systems (DBMS), including physical and logical schema, data independence, data models, database languages, metadata, transactions, concurrency, and database administration. It highlights the differences between file-processing systems and DBMS, advantages and disadvantages of using a DBMS, and the responsibilities of a database administrator. The text also covers programming languages used in DBMS, including procedural (e.g., C, Java) and non-procedural (e.g., SQL) languages, and how to set up a database for an enterprise.\n\nThe key concepts and their connections can be summarized as follows:\n\n* Physical schema: the internal representation of data on storage devices\n* Logical schema: the conceptual structure of data\n* Data independence: the ability to modify the physical schema without affecting the logical schema\n* Data models: entity-relationship model, relational data model, object-oriented data model, and object-relational data model\n* Database languages: data definition language (DDL), data manipulation language (DML), and query language (QL)\n* Metadata: data that describes the structure of the database\n* Transactions: a sequence of operations performed as a single, all-or-nothing unit\n* Concurrency: multiple transactions accessing the same data simultaneously\n* Database administration: managing the creation, modification, and deletion of databases\n\nOverall, the text provides an overview of the fundamental concepts and challenges involved in designing and managing a DBMS.", "214": "Here is a concise summary of the text:\n\nThe key concepts discussed in this text include physical and logical schema, data independence, data models (entity-relationship, relational, object-oriented, and object-relational), database languages (data definition, manipulation, and query), metadata, and transactions. The importance of a Database Management System (DBMS) is highlighted, with advantages such as improved data sharing, reduced data redundancy, and enhanced security. However, two disadvantages are also mentioned: the need for complex software and hardware, and potential performance issues. Physical data independence refers to the ability to modify the physical storage without affecting the logical structure of the database, while logical data independence ensures that changes to the conceptual schema do not affect the external interface. The DBMS is responsible for ensuring data integrity, concurrency control, and transactions management. The text also mentions various programming languages (procedural and non-procedural) and their ease of use, as well as the six major steps in setting up a database for an enterprise.", "215": "Here is a concise summary of the text:\n\nThe chapter discusses various aspects of Database Management Systems (DBMS). It highlights key differences between file-processing systems and DBMS, emphasizing advantages such as data independence, concurrency control, and transactions. The importance of physical and logical schema design is also emphasized, illustrating how these concepts ensure data independence. Additionally, the role of a database administrator (DBA) in managing databases and resolving potential issues is discussed. Furthermore, programming languages used for database management are categorized into procedural and non-procedural languages, with the former being considered easier to learn and use. Finally, the chapter outlines the major steps involved in setting up a database for an enterprise.", "216": "Here's a concise summary of the text:\n\nThe chapter introduces key concepts related to databases, including physical and logical schema, data independence, and various data models (entity-relationship, relational, object-oriented, and object-relational). It also covers database languages (data definition, manipulation, and query), metadata, and application programs. Additionally, it highlights the importance of a database administrator (DBA) and transactions in managing concurrency between client and server machines. The chapter concludes with exercises that explore differences between file-processing systems and DBMSs, advantages and disadvantages of using a DBMS, responsibilities of a DBMS, roles of a DBA, programming languages, and steps for setting up a database.\n\nThe key concepts and their connections can be summarized as follows:\n\n* Physical schema refers to the actual storage and organization of data in a database, while logical schema represents the conceptual view of the data.\n* Data independence allows changes to the physical schema without affecting the logical schema, making it easier to modify or update the database.\n* Database languages enable users to define, manipulate, and query data in the database.\n* Metadata provides information about the structure and organization of the database.\n* A DBA is responsible for ensuring data consistency and integrity, as well as managing transactions to prevent conflicts between concurrent access requests.\n\nOverall, the chapter emphasizes the importance of understanding the relationships between these concepts and how they contribute to effective database design, management, and use.", "217": "Here is a concise summary of the text:\n\nThe text discusses key concepts related to databases and their management. It highlights differences between file-processing systems and Database Management Systems (DBMS), noting that DBMS provides advantages such as physical data independence, logical schema, and support for multiple users. The text also covers various aspects of database design, including entity-relationship models, relational and object-oriented data models, and database languages. Additionally, it touches on the importance of metadata, transactions, concurrency, and client-server machines. Furthermore, the responsibilities of a DBA (Database Administrator) are outlined, as well as the five main functions they perform, which include ensuring data integrity, handling transactions, and managing database resources.", "218": "Here is a concise summary of the provided text:\n\nThe text discusses key concepts related to databases and their management. It highlights differences between file-processing systems and Database Management Systems (DBMS), advantages of DBMS, and disadvantages such as increased complexity and potential data inconsistencies. The chapter also explores physical and logical data independence, which refers to the separation of conceptual and external views of data. Additionally, it outlines responsibilities of a DBMS, including storing and retrieving data efficiently, handling concurrent transactions, and providing metadata management. Furthermore, the text introduces five main functions of a Database Administrator (DBA), such as designing databases, ensuring data integrity, and resolving conflicts between concurrent transactions. Finally, it lists programming languages and their characteristics, concluding that procedural languages are generally easier to learn and use due to their more straightforward syntax and structure.", "219": "Here's a concise summary of the text:\n\nThe text discusses key concepts related to databases and database management systems (DBMS). It highlights the differences between file-processing systems and DBMS, emphasizing the advantages of using a DBMS. The text also explores physical and logical data independence, explaining that physical schema independence allows for changes in storage structures without affecting logical schemas, while logical schema independence ensures that changes in conceptual models do not affect physical storage. Additionally, it outlines the responsibilities of a DBMS, including managing data integrity, concurrency control, and transactions, as well as the roles of database administrators. The text also touches on programming languages, comparing procedural (e.g., C++, Java) to non-procedural (e.g., SQL) languages, noting that procedural languages are generally easier to learn and use. Finally, it provides an overview of the steps involved in setting up a database for an enterprise.", "220": "This text appears to be an introduction or overview chapter from a database systems textbook. The main concepts discussed are the setup of a database for an enterprise, data abstraction levels, schema vs instances, and bibliographical notes on databases and transaction processing. To summarize, setting up a database for an enterprise involves six major steps: [insert list of 6 steps]. Data abstraction is illustrated using a two-dimensional integer array example, highlighting the three levels of abstraction: conceptual, internal, and external. Additionally, the text distinguishes between a schema (the overall structure) and instances (specific data entries). The chapter concludes with a list of general purpose books, research paper collections, and web sites on databases and transaction processing, providing references for further reading.", "80": "Here's a concise summary of the text, focusing on key concepts and their connections:\n\nThe text discusses setting up a database for an enterprise and introduces three levels of data abstraction: internal, external, and conceptual. The example of a two-dimensional integer array illustrates these levels, showing how they relate to schema (the overall organization of data) and instances (specific data records). To set up a database, one would follow six major steps: defining the database purpose, identifying entities and relationships, designing the schema, creating the database, populating it with data, and maintaining its integrity. The text also lists various resources on databases, including textbooks and research papers, to provide further guidance on the topic.", "41": "This text appears to be an introduction to database systems, specifically discussing the setup process and fundamental concepts. The six major steps for setting up a database are not explicitly listed, but the text does provide context on database system concepts. It also illustrates the difference between three levels of data abstraction (schema, instances, and actual data) using a two-dimensional integer array as an example.\n\nThe text highlights the distinction between schema (the overall structure or organization of the data) and instances (specific values stored in the database). Additionally, it provides a list of general-purpose books, research paper collections, and web sites on databases, serving as a reference for further learning. Overall, the text sets the stage for exploring database systems, transaction processing, and related topics.", "81": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text provides an overview of database management systems (DBMS), highlighting key research papers, textbooks, and online resources. It notes that the relational model was introduced by Codd in 1970, which led to the development of DBMS technology over time. The text also mentions the evolution of DBMS, with various books and papers discussing research challenges and achievements in this field. Additionally, it provides an example of data abstraction levels (schema, instances) using a two-dimensional integer array, illustrating the difference between these concepts. The text concludes by listing bibliographical notes, including general-purpose books, research paper collections, and web sites on databases, as well as textbooks covering database systems and transaction processing. Overall, the text serves as an introduction to DBMS, highlighting its key concepts, evolution, and relevant resources for further learning.", "82": "Here is a concise summary of the text, focusing on key concepts and their connections:\n\nThe text provides an overview of database management systems (DBMS) and related research. It highlights notable papers and books in the field, including seminal works by Codd (1970) and Ramakrishnan and Gehrke (2000). The text also mentions various textbooks and research paper collections on databases, transaction processing, and DBMS concepts. Additionally, it provides a brief introduction to data abstraction levels (physical, conceptual, and logical) and the distinction between schema and instances using an example of a two-dimensional integer array.\n\nThe key connections in this summary are:\n\n1. The importance of understanding database management systems and related research.\n2. The significance of notable papers and books in shaping the field.\n3. The connection between data abstraction levels and schema/instances in DBMS concepts.\n\nOverall, the text provides a foundation for understanding databases and DBMS, highlighting key concepts and their connections.", "83": "Here is a concise summary of the text:\n\nThe text provides an overview of database management systems (DBMS) and offers resources for learning about DBMS. It cites various textbooks, research papers, and web sites that cover topics such as transaction processing, data abstraction, and schema and instances. The key concepts highlighted include the relational model introduced by Codd in 1970, the three levels of data abstraction (conceptual, internal, and external), and the difference between a schema (the structure) and instances (the actual data). The text also mentions the evolution of DBMS and the development of database technology. Overall, it serves as an introduction to the field of DBMS and provides resources for further learning and exploration.", "84": "Here is a concise summary of the text:\n\nThe provided text lists various sources related to database management, including textbooks, research papers, and online resources. These sources cover topics such as transaction processing, database systems, and research challenges in the field. The text also highlights key concepts and milestones, such as the introduction of the relational model by Edgar Codd in 1970. Additionally, it provides information on where to find more details about database research, including the ACM Special Interest Group on Management of Data (SIGMOD) website and vendor websites for various database products.", "85": "Here is a concise summary of the text:\n\nThe relational model was introduced in 1970 by Codd's landmark paper, marking the beginning of database management systems (DBMS). Since then, DBMS technology has evolved and developed through discussions outlined in papers by Fry and Sibley (1976) and Sibley (1976). Today, there are numerous commercial DBMS products available, including IBM DB2, Oracle, Microsoft SQL Server, Informix, and Sybase. Some of these systems offer free versions for personal or non-commercial use, while others require payment for actual deployment. Additionally, there are free/public domain DBMS options like MySQL and PostgreSQL that are widely used.", "86": "Here is a concise summary of the text:\n\nThe article discusses the evolution of Database Management Systems (DBMS) and the development of database technology. The landmark paper \"codd\" in 1970 introduced the relational model, which led to the development of various DBMS products. Today, there are numerous commercial DBMS systems available, including IBM DB2, Oracle, Microsoft SQL Server, Informix, and Sybase. Some of these systems offer free or public domain versions for personal use or development, while others require payment for deployment. The article also mentions a few widely used free/public domain options like MySQL and PostgresSQL.", "221": "Here is a concise summary of the text:\n\nThe provided text appears to be a reference to various database-related links and resources. Specifically, it mentions two vendors: MySQL (www.mysql.com) and PostgresSQL (www.postgresql.org). Additionally, it notes that a more comprehensive list of vendor websites and other information can be found on the home page of this book, located at www.research.bell-labs.com/topic/books/db-book.", "87": "Unfortunately, the provided text does not contain any significant or meaningful content. It appears to be a reference to some vendor websites related to database systems, but it is extremely brief and lacks context.\n\nHowever, if I were to summarize this text, I would say that it mentions two databases: MySQL (www.mysql.com) and PostgreSQL (www.postgresql.org). The text also suggests that more information about these databases can be found on the home page of a book at www.research.bell-labs.com/topic/books/db-book.", "88": "This text does not appear to contain any meaningful content or key concepts. It seems to be a list of URLs related to databases, specifically mentioning PostgreSQL and PostgresSQL. The main connection is that these are database-related websites, but there is no further information provided about the topics they cover or how they relate to each other."}</data>
<node id="silberschatz-korth-sudarshan">
  <data key="d1">silberschatz-ch-1.pdf-1,silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-62,silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-52,silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-36,silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-0</data>
  <data key="d2">4</data>
</node>
<node id="database system concepts, fourth edition">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-27,silberschatz-ch-1.pdf-33,silberschatz-ch-1.pdf-19,silberschatz-ch-1.pdf-62,silberschatz-ch-1.pdf-0,silberschatz-ch-1.pdf-36</data>
  <data key="d2">4</data>
</node>
<node id="mcgraw-hill companies">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-0</data>
  <data key="d2">4</data>
</node>
<node id="a database - management system (dbms)">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">2</data>
</node>
<node id="database">
  <data key="d1">silberschatz-ch-1.pdf-21,silberschatz-ch-1.pdf-44,silberschatz-ch-1.pdf-23,silberschatz-ch-1.pdf-42,silberschatz-ch-1.pdf-3,silberschatz-ch-1.pdf-40,silberschatz-ch-1.pdf-41,silberschatz-ch-1.pdf-18,silberschatz-ch-1.pdf-51,silberschatz-ch-1.pdf-59,silberschatz-ch-1.pdf-58,silberschatz-ch-1.pdf-17,silberschatz-ch-1.pdf-35,silberschatz-ch-1.pdf-0,silberschatz-ch-1.pdf-9</data>
  <data key="d2">2</data>
</node>
<node id="the collection of data, usually referred to as the database">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">10</data>
</node>
<node id="information">
  <data key="d1">silberschatz-ch-1.pdf-58,silberschatz-ch-1.pdf-46,silberschatz-ch-1.pdf-0,silberschatz-ch-1.pdf-2,silberschatz-ch-1.pdf-35,silberschatz-ch-1.pdf-17</data>
  <data key="d2">10</data>
</node>
<node id="the primary goal of a dbms">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">89</data>
</node>
<node id="provide way to store and retrieve database information">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">89</data>
</node>
<node id="database systems">
  <data key="d1">silberschatz-ch-1.pdf-57,silberschatz-ch-1.pdf-1,silberschatz-ch-1.pdf-30,silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-0,silberschatz-ch-1.pdf-17,silberschatz-ch-1.pdf-12</data>
  <data key="d2">1</data>
</node>
<node id="managing large bodies of information">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">1</data>
</node>
<node id="management of data">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">90</data>
</node>
<node id="define structures for storage of information">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">90</data>
</node>
<node id="providing mechanisms for the manipulation of information">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">91</data>
</node>
<node id="manipulate information">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">91</data>
</node>
<node id="the database system must ensure the safety of the information stored">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">92</data>
</node>
<node id="ensure safety of information">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">92</data>
</node>
<node id="the system must avoid possible anomalous results">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">93</data>
</node>
<node id="avoid anomalous results">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">93</data>
</node>
<node id="computer scientists have developed a large body of concepts and techniques for managing data">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">94</data>
</node>
<node id="develop concepts and techniques">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">94</data>
</node>
<node id="these concepts and technique form the focus of this book">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">95</data>
</node>
<node id="managing data">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">95</data>
</node>
<node id="this chapter briefly introduces the principles of database systems">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">96</data>
</node>
<node id="introduce principles of database systems">
  <data key="d1">silberschatz-ch-1.pdf-0</data>
  <data key="d2">96</data>
</node>
<node id="computer scientists">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">42</data>
</node>
<node id="concepts and techniques">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">42</data>
</node>
<node id="focus of this book">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">42</data>
</node>
<node id="principles">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">1</data>
</node>
<node id="database system applications">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">97</data>
</node>
<node id="widely used">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">97</data>
</node>
<node id="banking">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">98</data>
</node>
<node id="databases for customer information, accounts, and loans">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">98</data>
</node>
<node id="airlines">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">99</data>
</node>
<node id="databases in a geographically distributed manner">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">99</data>
</node>
<node id="universities">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">100</data>
</node>
<node id="databases for student information, course registrations, and grades">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">100</data>
</node>
<node id="Database System Concepts, fourth edition">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">4</data>
</node>
<node id="database system concepts">
  <data key="d1">silberschatz-ch-1.pdf-52,silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-1,silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-45</data>
  <data key="d2">4</data>
</node>
<node id="credit card transactions">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">101</data>
</node>
<node id="databases for purchases and generation of monthly statements">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">101</data>
</node>
<node id="telecommunication">
  <data key="d1">silberschatz-ch-1.pdf-1,silberschatz-ch-1.pdf-2</data>
  <data key="d2">10</data>
</node>
<node id="databases for keeping records and generating monthly bills">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">10</data>
</node>
<node id="finance">
  <data key="d1">silberschatz-ch-1.pdf-1,silberschatz-ch-1.pdf-2</data>
  <data key="d2">10</data>
</node>
<node id="databases for storing information about financial instruments">
  <data key="d1">silberschatz-ch-1.pdf-1</data>
  <data key="d2">10</data>
</node>
<node id="records">
  <data key="d1">silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-2</data>
  <data key="d2">10</data>
</node>
<node id="generates">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">10</data>
</node>
<node id="balances">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">10</data>
</node>
<node id="sales">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">0</data>
</node>
<node id="customer">
  <data key="d1">silberschatz-ch-1.pdf-21,silberschatz-ch-1.pdf-23,silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-20,silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-2,silberschatz-ch-1.pdf-22</data>
  <data key="d2">0</data>
</node>
<node id="product">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">0</data>
</node>
<node id="purchase">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">0</data>
</node>
<node id="manufacturing">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">22</data>
</node>
<node id="supply chain">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">22</data>
</node>
<node id="production">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">22</data>
</node>
<node id="inventories">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">22</data>
</node>
<node id="orders">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">22</data>
</node>
<node id="human resources">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">10</data>
</node>
<node id="paychecks">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">10</data>
</node>
<node id="databases">
  <data key="d1">silberschatz-ch-1.pdf-2,silberschatz-ch-1.pdf-17,silberschatz-ch-1.pdf-3</data>
  <data key="d2">31</data>
</node>
<node id="part">
  <data key="d1">silberschatz-ch-1.pdf-2</data>
  <data key="d2">31</data>
</node>
<node id="bank tellers">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">31</data>
</node>
<node id="automated teller machines">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">102</data>
</node>
<node id="users interact with databases">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">102</data>
</node>
<node id="phone interfaces">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">103</data>
</node>
<node id="deal directly with databases">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">103</data>
</node>
<node id="caller">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">32</data>
</node>
<node id="a number">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">32</data>
</node>
<node id="phone keys">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">32</data>
</node>
<node id="or select alternative options">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">32</data>
</node>
<node id="internet revolution">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">104</data>
</node>
<node id="direct user access to databases">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">104</data>
</node>
<node id="organizations">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">43</data>
</node>
<node id="phone interfaces to databases into web interfaces">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">43</data>
</node>
<node id="services and information online">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">43</data>
</node>
<node id="online bookstore">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">2</data>
</node>
<node id="user">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-44,silberschatz-ch-1.pdf-36,silberschatz-ch-1.pdf-3</data>
  <data key="d2">3</data>
</node>
<node id="order stored in database">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">3</data>
</node>
<node id="bank website">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">105</data>
</node>
<node id="bank's database system">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">105</data>
</node>
<node id="web site">
  <data key="d1">silberschatz-ch-1.pdf-3</data>
  <data key="d2">2</data>
</node>
<node id="Bank">
  <data key="d1">silberschatz-ch-1.pdf-4,silberschatz-ch-1.pdf-5</data>
  <data key="d2">18</data>
</node>
<node id="Database System">
  <data key="d1">silberschatz-ch-1.pdf-4,silberschatz-ch-1.pdf-40</data>
  <data key="d2">18</data>
</node>
<node id="Web Site">
  <data key="d1">silberschatz-ch-1.pdf-4</data>
  <data key="d2">11</data>
</node>
<node id="Database">
  <data key="d1">silberschatz-ch-1.pdf-4,silberschatz-ch-1.pdf-34,silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="User">
  <data key="d1">silberschatz-ch-1.pdf-4</data>
  <data key="d2">11</data>
</node>
<node id="Oracle">
  <data key="d1">silberschatz-ch-1.pdf-4,silberschatz-ch-1.pdf-64</data>
  <data key="d2">7</data>
</node>
<node id="none">
  <data key="d1">silberschatz-ch-1.pdf-4</data>
  <data key="d2">7</data>
</node>
<node id="Microsoft">
  <data key="d1">silberschatz-ch-1.pdf-4,silberschatz-ch-1.pdf-64</data>
  <data key="d2">7</data>
</node>
<node id="IBM">
  <data key="d1">silberschatz-ch-1.pdf-4,silberschatz-ch-1.pdf-55,silberschatz-ch-1.pdf-54,silberschatz-ch-1.pdf-64</data>
  <data key="d2">7</data>
</node>
<node id="Savings Bank Enterprise">
  <data key="d1">silberschatz-ch-1.pdf-4</data>
  <data key="d2">11</data>
</node>
<node id="Enterprise">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">106</data>
</node>
<node id="Operating System Files">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">106</data>
</node>
<node id="System">
  <data key="d1">silberschatz-ch-1.pdf-5,silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Information">
  <data key="d1">silberschatz-ch-1.pdf-5,silberschatz-ch-1.pdf-6,silberschatz-ch-1.pdf-45</data>
  <data key="d2">9</data>
</node>
<node id="Application Programs">
  <data key="d1">silberschatz-ch-1.pdf-5,silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Files">
  <data key="d1">silberschatz-ch-1.pdf-5,silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Program">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">8</data>
</node>
<node id="Account">
  <data key="d1">silberschatz-ch-1.pdf-5,silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="New Account">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">8</data>
</node>
<node id="Account Balance">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">8</data>
</node>
<node id="Monthly Statements">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">8</data>
</node>
<node id="System Programmers">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">9</data>
</node>
<node id="Offer Checking Accounts">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">18</data>
</node>
<node id="Permanent Files">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">18</data>
</node>
<node id="New Application Programs">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">18</data>
</node>
<node id="Files and Application Programs">
  <data key="d1">silberschatz-ch-1.pdf-5,silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Operating System">
  <data key="d1">silberschatz-ch-1.pdf-5,silberschatz-ch-1.pdf-6</data>
  <data key="d2">44</data>
</node>
<node id="File Processing System">
  <data key="d1">silberschatz-ch-1.pdf-5</data>
  <data key="d2">44</data>
</node>
<node id="Typical File-Processing System">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">44</data>
</node>
<node id="Permanent Records">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Records from Files">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Records to Files">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Organizations">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">107</data>
</node>
<node id="File-Processing Systems">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">107</data>
</node>
<node id="Programmers">
  <data key="d1">silberschatz-ch-1.pdf-16,silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Different Formats">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Programs">
  <data key="d1">silberschatz-ch-1.pdf-43,silberschatz-ch-1.pdf-6</data>
  <data key="d2">11</data>
</node>
<node id="Several Programming Languages">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">11</data>
</node>
<node id="Several Places">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">9</data>
</node>
<node id="Customer">
  <data key="d1">silberschatz-ch-1.pdf-26,silberschatz-ch-1.pdf-6</data>
  <data key="d2">8</data>
</node>
<node id="Address and Telephone Number">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">8</data>
</node>
<node id="File">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">45</data>
</node>
<node id="Savings-Account Records">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">45</data>
</node>
<node id="Checking-Account Records">
  <data key="d1">silberschatz-ch-1.pdf-6</data>
  <data key="d2">45</data>
</node>
<node id="account records">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">1</data>
</node>
<node id="checking">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">1</data>
</node>
<node id="higher storage and access cost">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">1</data>
</node>
<node id="data inconsistency">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-7</data>
  <data key="d2">1</data>
</node>
<node id="customer address">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">46</data>
</node>
<node id="savings account records">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">46</data>
</node>
<node id="elsewhere in the system">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">46</data>
</node>
<node id="bank officer">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">47</data>
</node>
<node id="names of all customers who live within a particular postal-code area">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">47</data>
</node>
<node id="data-processing department to generate such a list">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">47</data>
</node>
<node id="designers of the original system">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">108</data>
</node>
<node id="this request">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">108</data>
</node>
<node id="data-processing department">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">109</data>
</node>
<node id="an application program to generate the list of all customers">
  <data key="d1">silberschatz-ch-1.pdf-7</data>
  <data key="d2">109</data>
</node>
<node id="the mcgraw−hill companies">
  <data key="d1">silberschatz-ch-1.pdf-8,silberschatz-ch-1.pdf-27,silberschatz-ch-1.pdf-33,silberschatz-ch-1.pdf-19</data>
  <data key="d2">4</data>
</node>
<node id="edition">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">4</data>
</node>
<node id="introduction text">
  <data key="d1">silberschatz-ch-1.pdf-8,silberschatz-ch-1.pdf-39</data>
  <data key="d2">4</data>
</node>
<node id="a system programmer">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">110</data>
</node>
<node id="application program">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">110</data>
</node>
<node id="an officer">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">33</data>
</node>
<node id="list of all customers">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">33</data>
</node>
<node id="program to generate list">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">33</data>
</node>
<node id="list with account balance $10,000 or more">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">33</data>
</node>
<node id="introduction">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">4</data>
</node>
<node id="conventional file-processing environments">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">48</data>
</node>
<node id="retrieve data conveniently">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">48</data>
</node>
<node id="retrieving data efficiently">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">48</data>
</node>
<node id="data retrieval systems">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">111</data>
</node>
<node id="general use">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">111</data>
</node>
<node id="files">
  <data key="d1">silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-8</data>
  <data key="d2">34</data>
</node>
<node id="scattered data">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">34</data>
</node>
<node id="different formats">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">34</data>
</node>
<node id="application programs">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-47,silberschatz-ch-1.pdf-8,silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-16,silberschatz-ch-1.pdf-9,silberschatz-ch-1.pdf-18,silberschatz-ch-1.pdf-12</data>
  <data key="d2">1</data>
</node>
<node id="retrieving appropriate data">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">1</data>
</node>
<node id="data values">
  <data key="d1">silberschatz-ch-1.pdf-30,silberschatz-ch-1.pdf-8,silberschatz-ch-1.pdf-9</data>
  <data key="d2">2</data>
</node>
<node id="consistency constraints">
  <data key="d1">silberschatz-ch-1.pdf-8,silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-30,silberschatz-ch-1.pdf-9</data>
  <data key="d2">1</data>
</node>
<node id="bank account">
  <data key="d1">silberschatz-ch-1.pdf-8</data>
  <data key="d2">0</data>
</node>
<node id="balance">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-8,silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="developers">
  <data key="d1">silberschatz-ch-1.pdf-13,silberschatz-ch-1.pdf-9</data>
  <data key="d2">1</data>
</node>
<node id="constraints">
  <data key="d1">silberschatz-ch-1.pdf-30,silberschatz-ch-1.pdf-9</data>
  <data key="d2">1</data>
</node>
<node id="data items">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">1</data>
</node>
<node id="different files">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">1</data>
</node>
<node id="computer system">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">49</data>
</node>
<node id="failure">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">49</data>
</node>
<node id="system failure">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">112</data>
</node>
<node id="program execution">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">112</data>
</node>
<node id="program">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-17,silberschatz-ch-1.pdf-9</data>
  <data key="d2">14</data>
</node>
<node id="accounts">
  <data key="d1">silberschatz-ch-1.pdf-21,silberschatz-ch-1.pdf-9</data>
  <data key="d2">14</data>
</node>
<node id="inconsistent database state">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">49</data>
</node>
<node id="database consistency">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-9</data>
  <data key="d2">14</data>
</node>
<node id="both credit and debit">
  <data key="d1">silberschatz-ch-1.pdf-9</data>
  <data key="d2">14</data>
</node>
<node id="$50">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">14</data>
</node>
<node id="account b">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">14</data>
</node>
<node id="funds transfer">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-41</data>
  <data key="d2">2</data>
</node>
<node id="in its entirety or not at all">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">2</data>
</node>
<node id="conventional file-processing system">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">2</data>
</node>
<node id="atomicity">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-41</data>
  <data key="d2">2</data>
</node>
<node id="system">
  <data key="d1">silberschatz-ch-1.pdf-44,silberschatz-ch-1.pdf-13,silberschatz-ch-1.pdf-12,silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-11,silberschatz-ch-1.pdf-47,silberschatz-ch-1.pdf-36,silberschatz-ch-1.pdf-58</data>
  <data key="d2">3</data>
</node>
<node id="multiple users to update the data simultaneously">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">3</data>
</node>
<node id="bank account a">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">17</data>
</node>
<node id="$500">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-11,silberschatz-ch-1.pdf-23</data>
  <data key="d2">17</data>
</node>
<node id="customers">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-21</data>
  <data key="d2">14</data>
</node>
<node id="account a">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">14</data>
</node>
<node id="programs">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-11</data>
  <data key="d2">17</data>
</node>
<node id="old balance">
  <data key="d1">silberschatz-ch-1.pdf-10,silberschatz-ch-1.pdf-11</data>
  <data key="d2">17</data>
</node>
<node id="value by amount being withdrawn">
  <data key="d1">silberschatz-ch-1.pdf-10</data>
  <data key="d2">17</data>
</node>
<node id="pro - grams">
  <data key="d1">silberschatz-ch-1.pdf-11</data>
  <data key="d2">113</data>
</node>
<node id="withdrawal">
  <data key="d1">silberschatz-ch-1.pdf-11</data>
  <data key="d2">113</data>
</node>
<node id="amount being withdrawn">
  <data key="d1">silberschatz-ch-1.pdf-11</data>
  <data key="d2">17</data>
</node>
<node id="result">
  <data key="d1">silberschatz-ch-1.pdf-11</data>
  <data key="d2">17</data>
</node>
<node id="each other">
  <data key="d1">silberschatz-ch-1.pdf-61,silberschatz-ch-1.pdf-11</data>
  <data key="d2">17</data>
</node>
<node id="some form of supervision">
  <data key="d1">silberschatz-ch-1.pdf-11</data>
  <data key="d2">3</data>
</node>
<node id="data">
  <data key="d1">silberschatz-ch-1.pdf-13,silberschatz-ch-1.pdf-46,silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-51,silberschatz-ch-1.pdf-52,silberschatz-ch-1.pdf-12,silberschatz-ch-1.pdf-11,silberschatz-ch-1.pdf-57,silberschatz-ch-1.pdf-53</data>
  <data key="d2">6</data>
</node>
<node id="many different application programs">
  <data key="d1">silberschatz-ch-1.pdf-11</data>
  <data key="d2">3</data>
</node>
<node id="security problems">
  <data key="d1">silberschatz-ch-1.pdf-11</data>
  <data key="d2">7</data>
</node>
<node id="database system">
  <data key="d1">silberschatz-ch-1.pdf-44,silberschatz-ch-1.pdf-46,silberschatz-ch-1.pdf-64,silberschatz-ch-1.pdf-30,silberschatz-ch-1.pdf-49,silberschatz-ch-1.pdf-12,silberschatz-ch-1.pdf-52,silberschatz-ch-1.pdf-57,silberschatz-ch-1.pdf-11,silberschatz-ch-1.pdf-31,silberschatz-ch-1.pdf-15,silberschatz-ch-1.pdf-35,silberschatz-ch-1.pdf-58</data>
  <data key="d2">7</data>
</node>
<node id="users">
  <data key="d1">silberschatz-ch-1.pdf-11,silberschatz-ch-1.pdf-41,silberschatz-ch-1.pdf-13,silberschatz-ch-1.pdf-31</data>
  <data key="d2">3</data>
</node>
<node id="payroll personnel">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">3</data>
</node>
<node id="information about various bank employees">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">3</data>
</node>
<node id="information about customer accounts">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">3</data>
</node>
<node id="the system in an ad hoc manner">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">1</data>
</node>
<node id="security constraints">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">114</data>
</node>
<node id="difﬁcult">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">114</data>
</node>
<node id="difﬁculties">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">1</data>
</node>
<node id="we">
  <data key="d1">silberschatz-ch-1.pdf-38,silberschatz-ch-1.pdf-12</data>
  <data key="d2">50</data>
</node>
<node id="concepts and algorithms that enable database systems to solve problems with ﬁle - processing systems">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">50</data>
</node>
<node id="this book">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">115</data>
</node>
<node id="a typical data - processing application found in a corporation">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">115</data>
</node>
<node id="files and a set of programs that allow users to access and modify these files">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">6</data>
</node>
<node id="the data">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">7</data>
</node>
<node id="the system">
  <data key="d1">silberschatz-ch-1.pdf-14,silberschatz-ch-1.pdf-12</data>
  <data key="d2">6</data>
</node>
<node id="need for efﬁciency">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">116</data>
</node>
<node id="complex data structures to represent data">
  <data key="d1">silberschatz-ch-1.pdf-12</data>
  <data key="d2">116</data>
</node>
<node id="designers">
  <data key="d1">silberschatz-ch-1.pdf-13</data>
  <data key="d2">117</data>
</node>
<node id="complex data structures">
  <data key="d1">silberschatz-ch-1.pdf-13</data>
  <data key="d2">117</data>
</node>
<node id="abstraction">
  <data key="d1">silberschatz-ch-1.pdf-13</data>
  <data key="d2">1</data>
</node>
<node id="physical level">
  <data key="d1">silberschatz-ch-1.pdf-13</data>
  <data key="d2">118</data>
</node>
<node id="complex low-level data structures">
  <data key="d1">silberschatz-ch-1.pdf-13</data>
  <data key="d2">118</data>
</node>
<node id="logical level">
  <data key="d1">silberschatz-ch-1.pdf-16,silberschatz-ch-1.pdf-13</data>
  <data key="d2">9</data>
</node>
<node id="what data are stored in the database">
  <data key="d1">silberschatz-ch-1.pdf-13</data>
  <data key="d2">9</data>
</node>
<node id="relationships among those data">
  <data key="d1">silberschatz-ch-1.pdf-13</data>
  <data key="d2">9</data>
</node>
<node id="database administrators">
  <data key="d1">silberschatz-ch-1.pdf-15,silberschatz-ch-1.pdf-14,silberschatz-ch-1.pdf-13</data>
  <data key="d2">35</data>
</node>
<node id="logical level of abstraction">
  <data key="d1">silberschatz-ch-1.pdf-14,silberschatz-ch-1.pdf-13</data>
  <data key="d2">35</data>
</node>
<node id="silberschatz−korth−sudarshan">
  <data key="d1">silberschatz-ch-1.pdf-27,silberschatz-ch-1.pdf-33,silberschatz-ch-1.pdf-30,silberschatz-ch-1.pdf-19,silberschatz-ch-1.pdf-14</data>
  <data key="d2">4</data>
</node>
<node id="Database System Concepts">
  <data key="d1">silberschatz-ch-1.pdf-61,silberschatz-ch-1.pdf-30,silberschatz-ch-1.pdf-14</data>
  <data key="d2">4</data>
</node>
<node id="information to keep in the database">
  <data key="d1">silberschatz-ch-1.pdf-14</data>
  <data key="d2">35</data>
</node>
<node id="users of the database system">
  <data key="d1">silberschatz-ch-1.pdf-14</data>
  <data key="d2">119</data>
</node>
<node id="part of the database">
  <data key="d1">silberschatz-ch-1.pdf-14</data>
  <data key="d2">119</data>
</node>
<node id="the view level of abstraction">
  <data key="d1">silberschatz-ch-1.pdf-14</data>
  <data key="d2">120</data>
</node>
<node id="to simplify their interaction with the system">
  <data key="d1">silberschatz-ch-1.pdf-14</data>
  <data key="d2">120</data>
</node>
<node id="many views for the same database">
  <data key="d1">silberschatz-ch-1.pdf-14</data>
  <data key="d2">6</data>
</node>
<node id="text">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">0</data>
</node>
<node id="record type">
  <data key="d1">silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-23,silberschatz-ch-1.pdf-15</data>
  <data key="d2">0</data>
</node>
<node id="Pascal-like language">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">51</data>
</node>
<node id="customer record type">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">51</data>
</node>
<node id="banking enterprise">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">36</data>
</node>
<node id="several record types">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">36</data>
</node>
<node id="account record type">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">36</data>
</node>
<node id="employee record type">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">36</data>
</node>
<node id="block of storage locations">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">0</data>
</node>
<node id="physical level detail from programmers">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">51</data>
</node>
<node id="lowest-level storage details from database programmers">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">7</data>
</node>
<node id="concerned with">
  <data key="d1">silberschatz-ch-1.pdf-15</data>
  <data key="d2">35</data>
</node>
<node id="The Mcgraw-Hill Companies">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">4</data>
</node>
<node id="2001">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-16,silberschatz-ch-1.pdf-33,silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="Compiler">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">121</data>
</node>
<node id="detail from programmers">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">121</data>
</node>
<node id="Database system">
  <data key="d1">silberschatz-ch-1.pdf-29,silberschatz-ch-1.pdf-16,silberschatz-ch-1.pdf-50,silberschatz-ch-1.pdf-43</data>
  <data key="d2">5</data>
</node>
<node id="storage details from database programmers">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">5</data>
</node>
<node id="Database administrators">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">9</data>
</node>
<node id="physical organization of data">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">9</data>
</node>
<node id="Computer users">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">1</data>
</node>
<node id="Database users">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">122</data>
</node>
<node id="views of the database">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">122</data>
</node>
<node id="Views">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">123</data>
</node>
<node id="security mechanism to prevent access">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">123</data>
</node>
<node id="Tellers in a bank">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">124</data>
</node>
<node id="part of the database with information on customer accounts">
  <data key="d1">silberschatz-ch-1.pdf-16</data>
  <data key="d2">124</data>
</node>
<node id="certain parts">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">2</data>
</node>
<node id="tellers">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">125</data>
</node>
<node id="customer accounts">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">125</data>
</node>
<node id="employees">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">126</data>
</node>
<node id="salaries">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">126</data>
</node>
<node id="over time">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">31</data>
</node>
<node id="into databases">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">10</data>
</node>
<node id="from databases">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">10</data>
</node>
<node id="an instance">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">2</data>
</node>
<node id="instance">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">127</data>
</node>
<node id="the database at a particular moment">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">127</data>
</node>
<node id="a schema">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">2</data>
</node>
<node id="schema">
  <data key="d1">silberschatz-ch-1.pdf-59,silberschatz-ch-1.pdf-17,silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-18</data>
  <data key="d2">16</data>
</node>
<node id="the database design">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">16</data>
</node>
<node id="variable declarations in a database schema">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">14</data>
</node>
<node id="variables">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">128</data>
</node>
<node id="particular values">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">128</data>
</node>
<node id="values of variables">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">129</data>
</node>
<node id="an instance of a database schema">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">129</data>
</node>
<node id="several schemas">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">1</data>
</node>
<node id="schemas">
  <data key="d1">silberschatz-ch-1.pdf-18,silberschatz-ch-1.pdf-17</data>
  <data key="d2">52</data>
</node>
<node id="according to the levels of abstraction">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">52</data>
</node>
<node id="physical schema">
  <data key="d1">silberschatz-ch-1.pdf-18,silberschatz-ch-1.pdf-17</data>
  <data key="d2">1</data>
</node>
<node id="the database design at the physical level">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">1</data>
</node>
<node id="logical schema">
  <data key="d1">silberschatz-ch-1.pdf-18,silberschatz-ch-1.pdf-17</data>
  <data key="d2">16</data>
</node>
<node id="the database design at the logical level">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">16</data>
</node>
<node id="several schemas at the view level">
  <data key="d1">silberschatz-ch-1.pdf-17</data>
  <data key="d2">2</data>
</node>
<node id="database design">
  <data key="d1">silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-18</data>
  <data key="d2">16</data>
</node>
<node id="without affecting application programs">
  <data key="d1">silberschatz-ch-1.pdf-18</data>
  <data key="d2">16</data>
</node>
<node id="languages">
  <data key="d1">silberschatz-ch-1.pdf-18</data>
  <data key="d2">52</data>
</node>
<node id="data model">
  <data key="d1">silberschatz-ch-1.pdf-31,silberschatz-ch-1.pdf-58,silberschatz-ch-1.pdf-19,silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-18</data>
  <data key="d2">3</data>
</node>
<node id="data, data relationships, data semantics, and consistency constraints">
  <data key="d1">silberschatz-ch-1.pdf-18</data>
  <data key="d2">3</data>
</node>
<node id="data models">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-18,silberschatz-ch-1.pdf-28</data>
  <data key="d2">15</data>
</node>
<node id="silberschatz−korth−sudarshan : database system concepts, fourth edition">
  <data key="d1">silberschatz-ch-1.pdf-18</data>
  <data key="d2">15</data>
</node>
<node id="book">
  <data key="d1">silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-65,silberschatz-ch-1.pdf-19</data>
  <data key="d2">4</data>
</node>
<node id="entity - relationship model">
  <data key="d1">silberschatz-ch-1.pdf-19</data>
  <data key="d2">3</data>
</node>
<node id="entities">
  <data key="d1">silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-19</data>
  <data key="d2">0</data>
</node>
<node id="basic objects">
  <data key="d1">silberschatz-ch-1.pdf-19</data>
  <data key="d2">0</data>
</node>
<node id="real world">
  <data key="d1">silberschatz-ch-1.pdf-19</data>
  <data key="d2">130</data>
</node>
<node id="perception">
  <data key="d1">silberschatz-ch-1.pdf-19</data>
  <data key="d2">130</data>
</node>
<node id="tributes account">
  <data key="d1">silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="number">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="name">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="street address">
  <data key="d1">silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="city">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="id">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22,silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="customer - id">
  <data key="d1">silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="person">
  <data key="d1">silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="U.S. government">
  <data key="d1">silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="social - security number">
  <data key="d1">silberschatz-ch-1.pdf-20</data>
  <data key="d2">0</data>
</node>
<node id="account">
  <data key="d1">silberschatz-ch-1.pdf-21,silberschatz-ch-1.pdf-23,silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-20,silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22</data>
  <data key="d2">0</data>
</node>
<node id="entity sets">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">14</data>
</node>
<node id="rectangle">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">0</data>
</node>
<node id="entity set">
  <data key="d1">silberschatz-ch-1.pdf-21,silberschatz-ch-1.pdf-25</data>
  <data key="d2">0</data>
</node>
<node id="ellipse">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">131</data>
</node>
<node id="attribute">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">131</data>
</node>
<node id="diamond">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">132</data>
</node>
<node id="relationship">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">132</data>
</node>
<node id="line">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">133</data>
</node>
<node id="attributes">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">133</data>
</node>
<node id="depositor">
  <data key="d1">silberschatz-ch-1.pdf-21,silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22</data>
  <data key="d2">0</data>
</node>
<node id="customer and account">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">0</data>
</node>
<node id="relationships">
  <data key="d1">silberschatz-ch-1.pdf-21</data>
  <data key="d2">14</data>
</node>
<node id="E-R model">
  <data key="d1">silberschatz-ch-1.pdf-21,silberschatz-ch-1.pdf-24</data>
  <data key="d2">12</data>
</node>
<node id="relationship set">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22</data>
  <data key="d2">0</data>
</node>
<node id="entity-relationship model">
  <data key="d1">silberschatz-ch-1.pdf-22</data>
  <data key="d2">16</data>
</node>
<node id="book (Database System Concepts, fourth edition)">
  <data key="d1">silberschatz-ch-1.pdf-22</data>
  <data key="d2">4</data>
</node>
<node id="chapter 2">
  <data key="d1">silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-22</data>
  <data key="d2">15</data>
</node>
<node id="street">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-22</data>
  <data key="d2">0</data>
</node>
<node id="table">
  <data key="d1">silberschatz-ch-1.pdf-23,silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-22</data>
  <data key="d2">0</data>
</node>
<node id="figure 1.2">
  <data key="d1">silberschatz-ch-1.pdf-22</data>
  <data key="d2">134</data>
</node>
<node id="ER diagram">
  <data key="d1">silberschatz-ch-1.pdf-22</data>
  <data key="d2">134</data>
</node>
<node id="figure 1.3">
  <data key="d1">silberschatz-ch-1.pdf-22</data>
  <data key="d2">135</data>
</node>
<node id="relational database">
  <data key="d1">silberschatz-ch-1.pdf-22</data>
  <data key="d2">135</data>
</node>
<node id="id 192 - 83 - 7465">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="johnson">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="12 alma st, palo alto">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="$900">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="customer whose customer - id is 192 - 83 - 7465">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="customer whose customer - id is 019 - 28 - 3746">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="a - 201">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="record-based model">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">12</data>
</node>
<node id="relational model">
  <data key="d1">silberschatz-ch-1.pdf-56,silberschatz-ch-1.pdf-23,silberschatz-ch-1.pdf-53,silberschatz-ch-1.pdf-64,silberschatz-ch-1.pdf-24</data>
  <data key="d2">12</data>
</node>
<node id="fixed-format records">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">2</data>
</node>
<node id="records of a particular type">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="fixed number of fields or attributes">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="attributes of the record type">
  <data key="d1">silberschatz-ch-1.pdf-23</data>
  <data key="d2">0</data>
</node>
<node id="fixed number of fields">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">0</data>
</node>
<node id="attributes of record type">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">0</data>
</node>
<node id="tables">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">34</data>
</node>
<node id="special character">
  <data key="d1">silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-35</data>
  <data key="d2">10</data>
</node>
<node id="different attributes of a record">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">10</data>
</node>
<node id="low-level implementation details">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">12</data>
</node>
<node id="relational data model">
  <data key="d1">silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-28,silberschatz-ch-1.pdf-58</data>
  <data key="d2">3</data>
</node>
<node id="current database systems">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">12</data>
</node>
<node id="chapters 3-7">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">136</data>
</node>
<node id="relational model in detail">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">136</data>
</node>
<node id="database designs">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">12</data>
</node>
<node id="translation process">
  <data key="d1">silberschatz-ch-1.pdf-24,silberschatz-ch-1.pdf-25</data>
  <data key="d2">15</data>
</node>
<node id="tables customer and account">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">137</data>
</node>
<node id="entity sets same name">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">137</data>
</node>
<node id="table depositor">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">138</data>
</node>
<node id="relationship set depositor">
  <data key="d1">silberschatz-ch-1.pdf-24</data>
  <data key="d2">138</data>
</node>
<node id="Silberschatz-Korth-Sudarshan">
  <data key="d1">silberschatz-ch-1.pdf-25,silberschatz-ch-1.pdf-57,silberschatz-ch-1.pdf-45</data>
  <data key="d2">15</data>
</node>
<node id="fourth edition">
  <data key="d1">silberschatz-ch-1.pdf-25</data>
  <data key="d2">4</data>
</node>
<node id="Lindsay">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">53</data>
</node>
<node id="Smith">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">53</data>
</node>
<node id="72 North St, Rye">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">53</data>
</node>
<node id="Customer Table">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="101">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="500">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="215">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="700">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="102">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="400">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="305">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="350">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="201">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="900">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="217">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="750">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="222">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="192-83-7465">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="Depositor">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">8</data>
</node>
<node id="Depositor Table">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">139</data>
</node>
<node id="Figure 1.3">
  <data key="d1">silberschatz-ch-1.pdf-26</data>
  <data key="d2">139</data>
</node>
<node id="chapter 7">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="object - oriented data model">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="e - r model">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="1. introduction text 21">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="schema designs">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="good schema designs">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="bad schema designs">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="encapsulation">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="methods ( functions )">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="object identity">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="chapter 8">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">4</data>
</node>
<node id="object - relational data model">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">54</data>
</node>
<node id="features of object - oriented data model and relational data model">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">54</data>
</node>
<node id="chapter 9">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">54</data>
</node>
<node id="semistructured data models">
  <data key="d1">silberschatz-ch-1.pdf-28,silberschatz-ch-1.pdf-27</data>
  <data key="d2">55</data>
</node>
<node id="where individual data items of the same type may have different sets of attributes">
  <data key="d1">silberschatz-ch-1.pdf-27</data>
  <data key="d2">55</data>
</node>
<node id="specification of data">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">55</data>
</node>
<node id="data models mentioned earlier">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">140</data>
</node>
<node id="same set of attributes">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">140</data>
</node>
<node id="xml">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">141</data>
</node>
<node id="semistructured data">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">141</data>
</node>
<node id="chapter 10">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">142</data>
</node>
<node id="it">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">142</data>
</node>
<node id="network data model">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">3</data>
</node>
<node id="hierarchical data model">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">3</data>
</node>
<node id="task of modeling data">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">15</data>
</node>
<node id="appendices a and b">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">15</data>
</node>
<node id="database languages">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">56</data>
</node>
<node id="data definition language">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">56</data>
</node>
<node id="data manipulation language">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">56</data>
</node>
<node id="sql language">
  <data key="d1">silberschatz-ch-1.pdf-32,silberschatz-ch-1.pdf-28</data>
  <data key="d2">5</data>
</node>
<node id="single database language">
  <data key="d1">silberschatz-ch-1.pdf-28</data>
  <data key="d2">5</data>
</node>
<node id="SQL language">
  <data key="d1">silberschatz-ch-1.pdf-29,silberschatz-ch-1.pdf-31</data>
  <data key="d2">5</data>
</node>
<node id="Database language">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">5</data>
</node>
<node id="Data definition language (DDL)">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">143</data>
</node>
<node id="Database schema">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">143</data>
</node>
<node id="DML">
  <data key="d1">silberschatz-ch-1.pdf-29,silberschatz-ch-1.pdf-30</data>
  <data key="d2">57</data>
</node>
<node id="Deﬁnitions">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">57</data>
</node>
<node id="Account table">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">5</data>
</node>
<node id="DML statement">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">5</data>
</node>
<node id="Data dictionary">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">5</data>
</node>
<node id="Metadata">
  <data key="d1">silberschatz-ch-1.pdf-61,silberschatz-ch-1.pdf-29</data>
  <data key="d2">5</data>
</node>
<node id="Schema of a table">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">5</data>
</node>
<node id="DDL">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">144</data>
</node>
<node id="Storage structure and access methods">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">144</data>
</node>
<node id="DDL statements">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">145</data>
</node>
<node id="Implementation details">
  <data key="d1">silberschatz-ch-1.pdf-29</data>
  <data key="d2">145</data>
</node>
<node id="statements">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">7</data>
</node>
<node id="implementation details">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">7</data>
</node>
<node id="hidden from users">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">7</data>
</node>
<node id="balance on account">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">146</data>
</node>
<node id="$ 100">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">146</data>
</node>
<node id="ddl">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-30</data>
  <data key="d2">3</data>
</node>
<node id="facilities to specify constraints">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">3</data>
</node>
<node id="text 22">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">58</data>
</node>
<node id="Introduction">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">58</data>
</node>
<node id="1.5">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">58</data>
</node>
<node id="Data - Manipulation Language">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">23</data>
</node>
<node id="retrieval">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">23</data>
</node>
<node id="insertion">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">23</data>
</node>
<node id="deletion">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">23</data>
</node>
<node id="modification">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">23</data>
</node>
<node id="access or manipulate data">
  <data key="d1">silberschatz-ch-1.pdf-30</data>
  <data key="d2">57</data>
</node>
<node id="language">
  <data key="d1">silberschatz-ch-1.pdf-59,silberschatz-ch-1.pdf-31</data>
  <data key="d2">3</data>
</node>
<node id="DMLs">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">59</data>
</node>
<node id="user to specify data">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">59</data>
</node>
<node id="user to get data">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">59</data>
</node>
<node id="declarative DMLs">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">60</data>
</node>
<node id="nonprocedural DMLs">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">60</data>
</node>
<node id="easier to learn and use">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">60</data>
</node>
<node id="to figure out efficient means of accessing data">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">7</data>
</node>
<node id="DML component">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">147</data>
</node>
<node id="nonprocedural">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">147</data>
</node>
<node id="query">
  <data key="d1">silberschatz-ch-1.pdf-31,silberschatz-ch-1.pdf-32</data>
  <data key="d2">5</data>
</node>
<node id="information retrieval">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">5</data>
</node>
<node id="portion of DML">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">5</data>
</node>
<node id="called query language">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">5</data>
</node>
<node id="query language">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">148</data>
</node>
<node id="synonymous with data manipulation language">
  <data key="d1">silberschatz-ch-1.pdf-31</data>
  <data key="d2">148</data>
</node>
<node id="name of customer">
  <data key="d1">silberschatz-ch-1.pdf-31,silberschatz-ch-1.pdf-32</data>
  <data key="d2">5</data>
</node>
<node id="customer-id">
  <data key="d1">silberschatz-ch-1.pdf-32</data>
  <data key="d2">0</data>
</node>
<node id="customer-name">
  <data key="d1">silberschatz-ch-1.pdf-32</data>
  <data key="d2">0</data>
</node>
<node id="rows to retrieve and display">
  <data key="d1">silberschatz-ch-1.pdf-32</data>
  <data key="d2">5</data>
</node>
<node id="information from multiple tables">
  <data key="d1">silberschatz-ch-1.pdf-32</data>
  <data key="d2">5</data>
</node>
<node id="balance of all accounts">
  <data key="d1">silberschatz-ch-1.pdf-32</data>
  <data key="d2">5</data>
</node>
<node id="account-number">
  <data key="d1">silberschatz-ch-1.pdf-32</data>
  <data key="d2">0</data>
</node>
<node id="company">
  <data key="d1">silberschatz-ch-1.pdf-32</data>
  <data key="d2">4</data>
</node>
<node id="1. introduction">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">4</data>
</node>
<node id="1. 6 database users and administrators">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">4</data>
</node>
<node id="copyright (©)">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">4</data>
</node>
<node id="if the above query were run on the tables in figure 1.3">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">149</data>
</node>
<node id="print out the balances of the two accounts">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">149</data>
</node>
<node id="the system would">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">61</data>
</node>
<node id="that the two accounts numbered a - 101 and a - 201 are owned by customer 192 - 83 - 7465">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">61</data>
</node>
<node id="the balances of the two accounts, namely 500 and 900">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">61</data>
</node>
<node id="there are">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">150</data>
</node>
<node id="a number of database query languages in use">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">150</data>
</node>
<node id="we study">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">151</data>
</node>
<node id="sql, in chapter 4">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">151</data>
</node>
<node id="we also study">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">152</data>
</node>
<node id="some other query languages in chapter 5">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">152</data>
</node>
<node id="the levels of abstraction that we discussed in section 1.3">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">62</data>
</node>
<node id="to deﬁning or structuring data">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">62</data>
</node>
<node id="to manipulating data">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">62</data>
</node>
<node id="at the physical level">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">153</data>
</node>
<node id="deﬁne algorithms that allow efﬁcient access to data">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">153</data>
</node>
<node id="at higher levels of abstraction">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">154</data>
</node>
<node id="ease of use">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">154</data>
</node>
<node id="the goal is">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">155</data>
</node>
<node id="to allow humans to interact efﬁciently with the system">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">155</data>
</node>
<node id="the query processor component of the database system">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">156</data>
</node>
<node id="dml queries into sequences">
  <data key="d1">silberschatz-ch-1.pdf-33</data>
  <data key="d2">156</data>
</node>
<node id="Application programs">
  <data key="d1">silberschatz-ch-1.pdf-34,silberschatz-ch-1.pdf-51</data>
  <data key="d2">11</data>
</node>
<node id="DML queries">
  <data key="d1">silberschatz-ch-1.pdf-34,silberschatz-ch-1.pdf-51</data>
  <data key="d2">2</data>
</node>
<node id="Sequences of actions at physical level">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">2</data>
</node>
<node id="Query processor component">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">2</data>
</node>
<node id="Host language">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">11</data>
</node>
<node id="Banking system">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">11</data>
</node>
<node id="DML statements">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">11</data>
</node>
<node id="Application program interface">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">157</data>
</node>
<node id="Send DML and DDL statements">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">157</data>
</node>
<node id="ODBC standard">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">158</data>
</node>
<node id="C language">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">158</data>
</node>
<node id="JDBC standard">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">159</data>
</node>
<node id="Java language">
  <data key="d1">silberschatz-ch-1.pdf-34</data>
  <data key="d2">159</data>
</node>
<node id="microsoft">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">63</data>
</node>
<node id="(odbc)">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">63</data>
</node>
<node id="application program interface standard">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">63</data>
</node>
<node id="java">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">29</data>
</node>
<node id="jdbc">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">29</data>
</node>
<node id="features">
  <data key="d1">silberschatz-ch-1.pdf-44,silberschatz-ch-1.pdf-35</data>
  <data key="d2">29</data>
</node>
<node id="host language">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">10</data>
</node>
<node id="dml calls">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">10</data>
</node>
<node id="precompiler">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">6</data>
</node>
<node id="dml statements">
  <data key="d1">silberschatz-ch-1.pdf-38,silberschatz-ch-1.pdf-49,silberschatz-ch-1.pdf-35</data>
  <data key="d2">6</data>
</node>
<node id="people">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">2</data>
</node>
<node id="database users or database administrators">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">2</data>
</node>
<node id="user interfaces">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">160</data>
</node>
<node id="different types of database-system users">
  <data key="d1">silberschatz-ch-1.pdf-35</data>
  <data key="d2">160</data>
</node>
<node id="naive users">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-36</data>
  <data key="d2">3</data>
</node>
<node id="bank teller">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">24</data>
</node>
<node id="transfer program">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">24</data>
</node>
<node id="amount of money">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">24</data>
</node>
<node id="account from which the money is to be transferred">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">24</data>
</node>
<node id="account to which the money is to be transferred">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">24</data>
</node>
<node id="account balance">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">3</data>
</node>
<node id="form">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">3</data>
</node>
<node id="web server">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">3</data>
</node>
<node id="forms interface">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-36</data>
  <data key="d2">3</data>
</node>
<node id="reports generated from the database">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-36</data>
  <data key="d2">3</data>
</node>
<node id="application programmers">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-36</data>
  <data key="d2">1</data>
</node>
<node id="application">
  <data key="d1">silberschatz-ch-1.pdf-36</data>
  <data key="d2">1</data>
</node>
<node id="many tools to develop user interfaces">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">1</data>
</node>
<node id="rad tools">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">161</data>
</node>
<node id="an application programmer to construct forms and reports">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">161</data>
</node>
<node id="forms and reports without writing a program">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">1</data>
</node>
<node id="special programming languages">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">64</data>
</node>
<node id="imperative control structures with data manipulation language statements">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">64</data>
</node>
<node id="features to facilitate the generation of forms and display of data on the screen">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">64</data>
</node>
<node id="major commercial database systems">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">162</data>
</node>
<node id="fourth-generation language">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">162</data>
</node>
<node id="sophisticated users">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">6</data>
</node>
<node id="the system without writing programs">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">6</data>
</node>
<node id="database query language">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">6</data>
</node>
<node id="query processor">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-38,silberschatz-ch-1.pdf-46</data>
  <data key="d2">6</data>
</node>
<node id="instructions that the storage manager understands">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">6</data>
</node>
<node id="analysts">
  <data key="d1">silberschatz-ch-1.pdf-37,silberschatz-ch-1.pdf-38</data>
  <data key="d2">1</data>
</node>
<node id="the database">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">1</data>
</node>
<node id="online analytical processing">
  <data key="d1">silberschatz-ch-1.pdf-37</data>
  <data key="d2">1</data>
</node>
<node id="queries">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-38,silberschatz-ch-1.pdf-51</data>
  <data key="d2">1</data>
</node>
<node id="OLAP tools">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">25</data>
</node>
<node id="analysts' tasks">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">25</data>
</node>
<node id="analyst">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">26</data>
</node>
<node id="summaries of data">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">26</data>
</node>
<node id="total sales by region">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">26</data>
</node>
<node id="total sales by product">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">26</data>
</node>
<node id="total sales by combination of region and product">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">26</data>
</node>
<node id="analyst to select specific regions">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">25</data>
</node>
<node id="analyst to look at data in more detail">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">25</data>
</node>
<node id="analyst to look at data in less detail">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">25</data>
</node>
<node id="data mining tools">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">163</data>
</node>
<node id="analysts find certain kinds of patterns">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">163</data>
</node>
<node id="OLAP tools and data mining">
  <data key="d1">silberschatz-ch-1.pdf-38</data>
  <data key="d2">50</data>
</node>
<node id="study">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">65</data>
</node>
<node id="Olap Tools">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">65</data>
</node>
<node id="Data Mining">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">65</data>
</node>
<node id="specialized users">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">66</data>
</node>
<node id="specialized database applications">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">66</data>
</node>
<node id="computer-aided design systems">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">66</data>
</node>
<node id="knowledge-silberschatz-korth-sudarshan: database system concepts, fourth edition">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">4</data>
</node>
<node id="database administrator">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">164</data>
</node>
<node id="data and programs that access those data">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">164</data>
</node>
<node id="DBA">
  <data key="d1">silberschatz-ch-1.pdf-39,silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="functions">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">2</data>
</node>
<node id="schema definition">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">37</data>
</node>
<node id="functions of a DBA">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">37</data>
</node>
<node id="storage structure and access-method definition">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">37</data>
</node>
<node id="schema and physical-organization modification">
  <data key="d1">silberschatz-ch-1.pdf-39</data>
  <data key="d2">37</data>
</node>
<node id="data definition statements">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="storage structure and access method">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="schema and physical organization">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="authorization for data access">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="Database Administrator">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">165</data>
</node>
<node id="data base access">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">165</data>
</node>
<node id="authorization information">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">18</data>
</node>
<node id="routine maintenance activities">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="free disk space">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="disk space">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="jobs running on the database">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="performance is not degraded">
  <data key="d1">silberschatz-ch-1.pdf-40</data>
  <data key="d2">2</data>
</node>
<node id="jobs running">
  <data key="d1">silberschatz-ch-1.pdf-41</data>
  <data key="d2">2</data>
</node>
<node id="performance degradation">
  <data key="d1">silberschatz-ch-1.pdf-41</data>
  <data key="d2">3</data>
</node>
<node id="transactions">
  <data key="d1">silberschatz-ch-1.pdf-44,silberschatz-ch-1.pdf-41,silberschatz-ch-1.pdf-42,silberschatz-ch-1.pdf-51</data>
  <data key="d2">27</data>
</node>
<node id="logical units of work">
  <data key="d1">silberschatz-ch-1.pdf-41</data>
  <data key="d2">27</data>
</node>
<node id="consistency">
  <data key="d1">silberschatz-ch-1.pdf-41</data>
  <data key="d2">2</data>
</node>
<node id="durability">
  <data key="d1">silberschatz-ch-1.pdf-41,silberschatz-ch-1.pdf-42</data>
  <data key="d2">2</data>
</node>
<node id="transaction">
  <data key="d1">silberschatz-ch-1.pdf-41,silberschatz-ch-1.pdf-42</data>
  <data key="d2">67</data>
</node>
<node id="single logical function">
  <data key="d1">silberschatz-ch-1.pdf-41,silberschatz-ch-1.pdf-42</data>
  <data key="d2">67</data>
</node>
<node id="each transaction">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">166</data>
</node>
<node id="unit of both atomicity and consistency">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">166</data>
</node>
<node id="database-consistency constraints">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">27</data>
</node>
<node id="when a transaction terminates">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">2</data>
</node>
<node id="during execution">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">67</data>
</node>
<node id="programmer">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">167</data>
</node>
<node id="various transactions">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">167</data>
</node>
<node id="transaction to transfer funds">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">168</data>
</node>
<node id="two separate programs">
  <data key="d1">silberschatz-ch-1.pdf-42</data>
  <data key="d2">168</data>
</node>
<node id="Transactions">
  <data key="d1">silberschatz-ch-1.pdf-61,silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="Transaction (transfer funds from account a to account b)">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="Programs (debit account a, credit account b)">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="Data-base system">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="Transaction-management component">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">169</data>
</node>
<node id="Atomicity and Durability">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">169</data>
</node>
<node id="Transaction">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="Failed transaction">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="Failure Recovery">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">11</data>
</node>
<node id="System Failures">
  <data key="d1">silberschatz-ch-1.pdf-43</data>
  <data key="d2">5</data>
</node>
<node id="state">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">2</data>
</node>
<node id="failure recovery">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">7</data>
</node>
<node id="system failures">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">3</data>
</node>
<node id="state prior to failure">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">2</data>
</node>
<node id="database concurrently">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">27</data>
</node>
<node id="concurrency control manager">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">170</data>
</node>
<node id="interaction among transactions">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">170</data>
</node>
<node id="manager">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">171</data>
</node>
<node id="consistency of database">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">171</data>
</node>
<node id="small personal computers">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">29</data>
</node>
<node id="systems">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">68</data>
</node>
<node id="one user to access database at a time">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">68</data>
</node>
<node id="backup and recovery">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">68</data>
</node>
<node id="backup and recovery to the user">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">3</data>
</node>
<node id="data manager">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">172</data>
</node>
<node id="especially main memory">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">172</data>
</node>
<node id="approach">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">173</data>
</node>
<node id="but inadequate for medium-to-large-scale enterprise">
  <data key="d1">silberschatz-ch-1.pdf-44</data>
  <data key="d2">173</data>
</node>
<node id="Database System Structure">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">69</data>
</node>
<node id="Modules">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">69</data>
</node>
<node id="Responsibilities">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">69</data>
</node>
<node id="Storage Manager">
  <data key="d1">silberschatz-ch-1.pdf-48,silberschatz-ch-1.pdf-45</data>
  <data key="d2">30</data>
</node>
<node id="Databases">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">30</data>
</node>
<node id="Query Processor Components">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">174</data>
</node>
<node id="Functional Components">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">174</data>
</node>
<node id="Large Amount of Storage Space">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">30</data>
</node>
<node id="Corporate Databases">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">175</data>
</node>
<node id="Gigabytes to Terabytes">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">175</data>
</node>
<node id="Gigabyte">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">176</data>
</node>
<node id="1000 Megabytes">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">176</data>
</node>
<node id="Terabyte">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">177</data>
</node>
<node id="1 Million Megabytes">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">177</data>
</node>
<node id="Main Memory">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">9</data>
</node>
<node id="Disks">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">9</data>
</node>
<node id="Disk Storage">
  <data key="d1">silberschatz-ch-1.pdf-45</data>
  <data key="d2">9</data>
</node>
<node id="disks">
  <data key="d1">silberschatz-ch-1.pdf-53,silberschatz-ch-1.pdf-46</data>
  <data key="d2">10</data>
</node>
<node id="disk storage and main memory">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">6</data>
</node>
<node id="disk storage">
  <data key="d1">silberschatz-ch-1.pdf-47,silberschatz-ch-1.pdf-46</data>
  <data key="d2">6</data>
</node>
<node id="main memory">
  <data key="d1">silberschatz-ch-1.pdf-52,silberschatz-ch-1.pdf-47,silberschatz-ch-1.pdf-46</data>
  <data key="d2">6</data>
</node>
<node id="data between disk and main memory">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">7</data>
</node>
<node id="high-level views">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">178</data>
</node>
<node id="goal">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">178</data>
</node>
<node id="users of the system">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">179</data>
</node>
<node id="physical details of implementation">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">179</data>
</node>
<node id="updates and queries">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">7</data>
</node>
<node id="efficient sequence of operations">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">7</data>
</node>
<node id="storage manager">
  <data key="d1">silberschatz-ch-1.pdf-47,silberschatz-ch-1.pdf-46,silberschatz-ch-1.pdf-51</data>
  <data key="d2">13</data>
</node>
<node id="low-level data stored in database and application programs">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">13</data>
</node>
<node id="file manager">
  <data key="d1">silberschatz-ch-1.pdf-47,silberschatz-ch-1.pdf-46</data>
  <data key="d2">13</data>
</node>
<node id="raw data">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">180</data>
</node>
<node id="disk using file system">
  <data key="d1">silberschatz-ch-1.pdf-46</data>
  <data key="d2">180</data>
</node>
<node id="low-level file-system commands">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">13</data>
</node>
<node id="data in the database">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">13</data>
</node>
<node id="data from the database">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">13</data>
</node>
<node id="authorization and integrity manager">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">70</data>
</node>
<node id="integrity constraints">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">70</data>
</node>
<node id="users to access data">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">70</data>
</node>
<node id="transaction manager">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">71</data>
</node>
<node id="database remains in a consistent state">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">71</data>
</node>
<node id="concurrent transaction executions proceed without conflict">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">71</data>
</node>
<node id="disk">
  <data key="d1">silberschatz-ch-1.pdf-53,silberschatz-ch-1.pdf-47</data>
  <data key="d2">13</data>
</node>
<node id="buffer manager">
  <data key="d1">silberschatz-ch-1.pdf-47</data>
  <data key="d2">6</data>
</node>
<node id="Buffer Manager">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">38</data>
</node>
<node id="fetching data from disk storage">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">38</data>
</node>
<node id="cache in main memory">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">38</data>
</node>
<node id="to handle large data sizes">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">38</data>
</node>
<node id="data structures as part of physical system implementation">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">30</data>
</node>
<node id="Data Files">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">181</data>
</node>
<node id="database itself">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">181</data>
</node>
<node id="Data Dictionary">
  <data key="d1">silberschatz-ch-1.pdf-61,silberschatz-ch-1.pdf-48</data>
  <data key="d2">5</data>
</node>
<node id="structure of the database and schema">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">5</data>
</node>
<node id="Indices">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">182</data>
</node>
<node id="data items that hold particular values">
  <data key="d1">silberschatz-ch-1.pdf-48</data>
  <data key="d2">182</data>
</node>
<node id="compiler">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">6</data>
</node>
<node id="evaluation plan">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">6</data>
</node>
<node id="query optimization">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">6</data>
</node>
<node id="lowest cost evaluation plan">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">6</data>
</node>
<node id="query compiler">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">72</data>
</node>
<node id="low-level instructions">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">72</data>
</node>
<node id="query evaluation engine">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">72</data>
</node>
<node id="application architectures">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">7</data>
</node>
<node id="client machines">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-49</data>
  <data key="d2">20</data>
</node>
<node id="remote database users">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">20</data>
</node>
<node id="server machines">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">7</data>
</node>
<node id="database applications">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-49</data>
  <data key="d2">20</data>
</node>
<node id="two or three parts">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">20</data>
</node>
<node id="two-tier architecture">
  <data key="d1">silberschatz-ch-1.pdf-52,silberschatz-ch-1.pdf-49</data>
  <data key="d2">5</data>
</node>
<node id="database system functionality">
  <data key="d1">silberschatz-ch-1.pdf-49,silberschatz-ch-1.pdf-50</data>
  <data key="d2">5</data>
</node>
<node id="client machine">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">5</data>
</node>
<node id="client and server machines">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">183</data>
</node>
<node id="through query language statements">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">183</data>
</node>
<node id="application program interface standards">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">184</data>
</node>
<node id="interaction between client and server machines">
  <data key="d1">silberschatz-ch-1.pdf-49</data>
  <data key="d2">184</data>
</node>
<node id="Client machine">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">5</data>
</node>
<node id="ODBC and JDBC">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">5</data>
</node>
<node id="Application server">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">5</data>
</node>
<node id="Business logic">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">5</data>
</node>
<node id="Three-tier architecture">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">73</data>
</node>
<node id="Large applications">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">73</data>
</node>
<node id="World wide web applications">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">73</data>
</node>
<node id="Data processing">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">74</data>
</node>
<node id="Computers">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">74</data>
</node>
<node id="Automation of data processing tasks">
  <data key="d1">silberschatz-ch-1.pdf-50</data>
  <data key="d2">74</data>
</node>
<node id="Hollerith">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">185</data>
</node>
<node id="punched cards">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">185</data>
</node>
<node id="Punched cards">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">186</data>
</node>
<node id="record U.S. census data">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">186</data>
</node>
<node id="Mechanical systems">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">187</data>
</node>
<node id="process data">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">187</data>
</node>
<node id="Naive users">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">13</data>
</node>
<node id="Storage manager">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">6</data>
</node>
<node id="Application programmers">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">188</data>
</node>
<node id="application interfaces">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">188</data>
</node>
<node id="Application interfaces">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">189</data>
</node>
<node id="application program object code">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">189</data>
</node>
<node id="Compiler and linker">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">190</data>
</node>
<node id="object code">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">190</data>
</node>
<node id="Buffer manager">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">191</data>
</node>
<node id="buffer">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">191</data>
</node>
<node id="File manager">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">192</data>
</node>
<node id="file">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">192</data>
</node>
<node id="Authorization and integrity manager">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">193</data>
</node>
<node id="integrity">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">193</data>
</node>
<node id="Transaction manager">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">27</data>
</node>
<node id="DML compiler and organizer">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">1</data>
</node>
<node id="Query evaluation engine">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">1</data>
</node>
<node id="DDL interpreter">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">194</data>
</node>
<node id="schema changes">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">194</data>
</node>
<node id="query tools">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">11</data>
</node>
<node id="Administration tools">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">195</data>
</node>
<node id="administration">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">195</data>
</node>
<node id="Sophisticated users (analysts)">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">196</data>
</node>
<node id="write queries">
  <data key="d1">silberschatz-ch-1.pdf-51</data>
  <data key="d2">196</data>
</node>
<node id="1950s">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">197</data>
</node>
<node id="magnetic tapes">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">197</data>
</node>
<node id="data processing tasks">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">198</data>
</node>
<node id="payroll">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">198</data>
</node>
<node id="processing of data">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">199</data>
</node>
<node id="reading from one or more tapes">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">199</data>
</node>
<node id="user application server">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">7</data>
</node>
<node id="three-tier architecture">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">5</data>
</node>
<node id="architecture">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">5</data>
</node>
<node id="punched card decks">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">6</data>
</node>
<node id="printers">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">6</data>
</node>
<node id="salary raises">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">39</data>
</node>
<node id="entering on punched cards">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">39</data>
</node>
<node id="a tape containing the master salary details">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">39</data>
</node>
<node id="the salary read from the master tape">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">39</data>
</node>
<node id="data sizes">
  <data key="d1">silberschatz-ch-1.pdf-52</data>
  <data key="d2">6</data>
</node>
<node id="salary">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">75</data>
</node>
<node id="master tape">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">75</data>
</node>
<node id="new master tape">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">75</data>
</node>
<node id="tapes">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">6</data>
</node>
<node id="data processing programs">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">6</data>
</node>
<node id="card decks">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">6</data>
</node>
<node id="tapes and card decks">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">6</data>
</node>
<node id="1960s">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">200</data>
</node>
<node id="widespread use of hard disks">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">200</data>
</node>
<node id="hard disks">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">201</data>
</node>
<node id="data processing">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">201</data>
</node>
<node id="position on disk">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">202</data>
</node>
<node id="accessing data">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">202</data>
</node>
<node id="location">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">13</data>
</node>
<node id="network and hierarchical databases">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">10</data>
</node>
<node id="data structures">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">13</data>
</node>
<node id="programmers">
  <data key="d1">silberschatz-ch-1.pdf-54,silberschatz-ch-1.pdf-53</data>
  <data key="d2">13</data>
</node>
<node id="Codd">
  <data key="d1">silberschatz-ch-1.pdf-54,silberschatz-ch-1.pdf-53</data>
  <data key="d2">12</data>
</node>
<node id="non-procedural ways of querying data">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">12</data>
</node>
<node id="similarity">
  <data key="d1">silberschatz-ch-1.pdf-53</data>
  <data key="d2">13</data>
</node>
<node id="IBM Research">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">21</data>
</node>
<node id="an efficient relational database system">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">21</data>
</node>
<node id="the prestigious Association of Computing Machinery Turing Award">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">12</data>
</node>
<node id="Relational Model">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">13</data>
</node>
<node id="1980s">
  <data key="d1">silberschatz-ch-1.pdf-56,silberschatz-ch-1.pdf-54</data>
  <data key="d2">12</data>
</node>
<node id="due to performance disadvantages">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">12</data>
</node>
<node id="System R">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">21</data>
</node>
<node id="Astrahan et al.">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">21</data>
</node>
<node id="Chamberlin et al.">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">21</data>
</node>
<node id="SQL/DS">
  <data key="d1">silberschatz-ch-1.pdf-55,silberschatz-ch-1.pdf-54</data>
  <data key="d2">7</data>
</node>
<node id="Initial Commercial Relational Database Systems">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">203</data>
</node>
<node id="the development of relational databases">
  <data key="d1">silberschatz-ch-1.pdf-54</data>
  <data key="d2">203</data>
</node>
<node id="Initial commercial relational database systems (IBM DB2, Oracle, Ingres, and DEC RDB)">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">204</data>
</node>
<node id="advancing techniques for efficient processing of declarative queries">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">204</data>
</node>
<node id="Relational databases">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">205</data>
</node>
<node id="Network and Hierarchical Database Systems">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">205</data>
</node>
<node id="Programmers using relational databases">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">40</data>
</node>
<node id="deal with many low-level implementation details">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">40</data>
</node>
<node id="code their queries in a procedural fashion">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">40</data>
</node>
<node id="keep efficiency in mind when designing their programs">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">40</data>
</node>
<node id="Relational database">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">206</data>
</node>
<node id="low-level tasks">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">206</data>
</node>
<node id="The programmer">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">207</data>
</node>
<node id="a logical level">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">207</data>
</node>
<node id="The Relational Model">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">208</data>
</node>
<node id="among data models">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">208</data>
</node>
<node id="The 1980s">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">76</data>
</node>
<node id="Parallel and Distributed Databases">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">76</data>
</node>
<node id="Object-Oriented Databases">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">76</data>
</node>
<node id="SQL Language">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">209</data>
</node>
<node id="Decision">
  <data key="d1">silberschatz-ch-1.pdf-55</data>
  <data key="d2">209</data>
</node>
<node id="parallel and distributed databases">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">12</data>
</node>
<node id="object-oriented databases">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">12</data>
</node>
<node id="1990s">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">19</data>
</node>
<node id="decision support applications">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">19</data>
</node>
<node id="transaction processing applications">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">12</data>
</node>
<node id="a major application area for databases">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">19</data>
</node>
<node id="large growths in usage">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">19</data>
</node>
<node id="parallel database products">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">19</data>
</node>
<node id="object-relational support">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">19</data>
</node>
<node id="late 1990s">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">28</data>
</node>
<node id="world wide web">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">28</data>
</node>
<node id="very high transaction processing rates">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">28</data>
</node>
<node id="high reliability and availability">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">28</data>
</node>
<node id="web interfaces to data">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">28</data>
</node>
<node id="summary">
  <data key="d1">silberschatz-ch-1.pdf-56</data>
  <data key="d2">15</data>
</node>
<node id="a collection of interrelated data">
  <data key="d1">silberschatz-ch-1.pdf-56,silberschatz-ch-1.pdf-57</data>
  <data key="d2">15</data>
</node>
<node id="a collection of programs to access that data">
  <data key="d1">silberschatz-ch-1.pdf-57</data>
  <data key="d2">15</data>
</node>
<node id="people to use in retrieving and storing information">
  <data key="d1">silberschatz-ch-1.pdf-57</data>
  <data key="d2">7</data>
</node>
<node id="with databases many times every day">
  <data key="d1">silberschatz-ch-1.pdf-57</data>
  <data key="d2">1</data>
</node>
<node id="large bodies of information">
  <data key="d1">silberschatz-ch-1.pdf-57</data>
  <data key="d2">1</data>
</node>
<node id="data management">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-57</data>
  <data key="d2">77</data>
</node>
<node id="and the provision of mechanisms for the manipulation of information">
  <data key="d1">silberschatz-ch-1.pdf-57</data>
  <data key="d2">77</data>
</node>
<node id="in the face of system crashes or attempts at unauthorized access">
  <data key="d1">silberschatz-ch-1.pdf-57</data>
  <data key="d2">7</data>
</node>
<node id="the">
  <data key="d1">silberschatz-ch-1.pdf-57</data>
  <data key="d2">6</data>
</node>
<node id="mechanisms">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">10</data>
</node>
<node id="safety of information stored">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">7</data>
</node>
<node id="anomalous results">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">3</data>
</node>
<node id="abstract view of data">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">7</data>
</node>
<node id="details of how data are stored and maintained">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">3</data>
</node>
<node id="underlying structure of database">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">3</data>
</node>
<node id="con - ceptual tools for describing data, data relationships, data semantics, and data constraints">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">3</data>
</node>
<node id="entity-relationship (e-r) data model">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">210</data>
</node>
<node id="data, relationships, and constraints">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">210</data>
</node>
<node id="data in databases">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">3</data>
</node>
<node id="other data models">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">211</data>
</node>
<node id="object-oriented model, object-relational model, and semistructured data models">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">211</data>
</node>
<node id="database schema">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">2</data>
</node>
<node id="data-definition language (ddl)">
  <data key="d1">silberschatz-ch-1.pdf-58</data>
  <data key="d2">2</data>
</node>
<node id="set of deﬁnitions">
  <data key="d1">silberschatz-ch-1.pdf-59</data>
  <data key="d2">16</data>
</node>
<node id="data - deﬁnition language (ddl)">
  <data key="d1">silberschatz-ch-1.pdf-59</data>
  <data key="d2">16</data>
</node>
<node id="ac - cess or manipulate data">
  <data key="d1">silberschatz-ch-1.pdf-59</data>
  <data key="d2">3</data>
</node>
<node id="dml">
  <data key="d1">silberschatz-ch-1.pdf-60,silberschatz-ch-1.pdf-59</data>
  <data key="d2">3</data>
</node>
<node id="m">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">3</data>
</node>
<node id="storage manager subsystem">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">1</data>
</node>
<node id="interface">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">1</data>
</node>
<node id="low-level data">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">1</data>
</node>
<node id="introduction text 33">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">4</data>
</node>
<node id="exercises 23">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">4</data>
</node>
<node id="front-end part and back end part">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">20</data>
</node>
<node id="two-tier architectures">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">212</data>
</node>
<node id="database running at the back end">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">212</data>
</node>
<node id="three-tier architectures">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">78</data>
</node>
<node id="application server and database server">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">78</data>
</node>
<node id="back end part">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">78</data>
</node>
<node id="dbms">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">1</data>
</node>
<node id="file systems">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">77</data>
</node>
<node id="data consistency">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">1</data>
</node>
<node id="data views">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">79</data>
</node>
<node id="data abstraction">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">79</data>
</node>
<node id="physical data">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">79</data>
</node>
<node id="database instance">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">16</data>
</node>
<node id="physical schema and logical schema">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">16</data>
</node>
<node id="physical data independence">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">15</data>
</node>
<node id="data dictionary">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">6</data>
</node>
<node id="metadata">
  <data key="d1">silberschatz-ch-1.pdf-60</data>
  <data key="d2">6</data>
</node>
<node id="Major Advantages of a Database System">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">4</data>
</node>
<node id="File-processing System">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">213</data>
</node>
<node id="DBMS">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">213</data>
</node>
<node id="Physical Schema">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">214</data>
</node>
<node id="Logical Schema">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">214</data>
</node>
<node id="Application Program">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">215</data>
</node>
<node id="Database Languages">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">215</data>
</node>
<node id="Database Administrator (dba)">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">11</data>
</node>
<node id="Client and Server Machines">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">17</data>
</node>
<node id="Procedural Programming Language">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">216</data>
</node>
<node id="Non-Procedural Programming Language">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">216</data>
</node>
<node id="Database Management System">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">217</data>
</node>
<node id="Setting up a Database">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">217</data>
</node>
<node id="Responsibilities of a Database Management System">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">218</data>
</node>
<node id="Discharging Problems">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">218</data>
</node>
<node id="Main Functions of a Database Administrator">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">219</data>
</node>
<node id="Tasks and Responsibilities">
  <data key="d1">silberschatz-ch-1.pdf-61</data>
  <data key="d2">219</data>
</node>
<node id="McGraw-Hill Companies">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">220</data>
</node>
<node id="textbook coverage">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">220</data>
</node>
<node id="Abiteboul et al.">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">80</data>
</node>
<node id="1995">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">80</data>
</node>
<node id="Date">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">80</data>
</node>
<node id="Elmasri and Navathe">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">41</data>
</node>
<node id="2000">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">41</data>
</node>
<node id="O'Neil and O'Neil">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">41</data>
</node>
<node id="Ramakrishnan and Gehrke">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">41</data>
</node>
<node id="Ullman">
  <data key="d1">silberschatz-ch-1.pdf-62,silberschatz-ch-1.pdf-63</data>
  <data key="d2">81</data>
</node>
<node id="1988">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">81</data>
</node>
<node id="Bernstein and Newcomer">
  <data key="d1">silberschatz-ch-1.pdf-62,silberschatz-ch-1.pdf-63</data>
  <data key="d2">82</data>
</node>
<node id="1997">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">82</data>
</node>
<node id="Gray and Reuter">
  <data key="d1">silberschatz-ch-1.pdf-62,silberschatz-ch-1.pdf-63</data>
  <data key="d2">83</data>
</node>
<node id="1993">
  <data key="d1">silberschatz-ch-1.pdf-62</data>
  <data key="d2">83</data>
</node>
<node id="Ramakrishnan">
  <data key="d1">silberschatz-ch-1.pdf-63</data>
  <data key="d2">84</data>
</node>
<node id="[2000]">
  <data key="d1">silberschatz-ch-1.pdf-63</data>
  <data key="d2">84</data>
</node>
<node id="Gehrke">
  <data key="d1">silberschatz-ch-1.pdf-63</data>
  <data key="d2">84</data>
</node>
<node id="[1988]">
  <data key="d1">silberschatz-ch-1.pdf-63</data>
  <data key="d2">81</data>
</node>
<node id="textbook coverage of transaction processing [1997]">
  <data key="d1">silberschatz-ch-1.pdf-63</data>
  <data key="d2">82</data>
</node>
<node id="textbook coverage of transaction processing [1993]">
  <data key="d1">silberschatz-ch-1.pdf-63</data>
  <data key="d2">83</data>
</node>
<node id="codd">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">12</data>
</node>
<node id="fry and sibley">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">85</data>
</node>
<node id="evolution of dbmss and development of database technology">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">85</data>
</node>
<node id="sibley">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">85</data>
</node>
<node id="DB2">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">7</data>
</node>
<node id="SQL Server">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">7</data>
</node>
<node id="Informix">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">7</data>
</node>
<node id="Sybase">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">7</data>
</node>
<node id="MySQL">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">86</data>
</node>
<node id="free/public domain database system">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">86</data>
</node>
<node id="PostgreSQL">
  <data key="d1">silberschatz-ch-1.pdf-64</data>
  <data key="d2">86</data>
</node>
<node id="com">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">221</data>
</node>
<node id="ql">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">221</data>
</node>
<node id="org">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">87</data>
</node>
<node id="postgressql">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">87</data>
</node>
<node id="www.postgressql.org">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">87</data>
</node>
<node id="research.bell-labs.com">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">4</data>
</node>
<node id="www.research.bell-labs.com">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">88</data>
</node>
<node id="db-book">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">88</data>
</node>
<node id="topic">
  <data key="d1">silberschatz-ch-1.pdf-65</data>
  <data key="d2">88</data>
</node>
<edge source="silberschatz-korth-sudarshan" target="database system concepts, fourth edition">
  <data key="d3">cover</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="Database System Concepts, fourth edition">
  <data key="d3">wrote</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="book (Database System Concepts, fourth edition)">
  <data key="d3">wrote</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="database system concepts">
  <data key="d3">wrote</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="fourth edition">
  <data key="d3">mentions</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="mcgraw-hill companies">
  <data key="d3">mentions</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="2001">
  <data key="d3">mentions</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="introduction text 33">
  <data key="d3">writes</data>
</edge>
<edge source="silberschatz-korth-sudarshan" target="exercises 23">
  <data key="d3">writes</data>
</edge>
<edge source="database system concepts, fourth edition" target="mcgraw-hill companies">
  <data key="d3">book</data>
</edge>
<edge source="database system concepts, fourth edition" target="silberschatz−korth−sudarshan">
  <data key="d3">author</data>
</edge>
<edge source="database system concepts, fourth edition" target="1. introduction">
  <data key="d3">contains</data>
</edge>
<edge source="database system concepts, fourth edition" target="1. 6 database users and administrators">
  <data key="d3">contains</data>
</edge>
<edge source="database system concepts, fourth edition" target="the mcgraw−hill companies">
  <data key="d3">mentions</data>
</edge>
<edge source="database system concepts, fourth edition" target="2001">
  <data key="d3">mentions</data>
</edge>
<edge source="a database - management system (dbms)" target="database">
  <data key="d3">definition</data>
</edge>
<edge source="database" target="online bookstore">
  <data key="d3">access data from</data>
</edge>
<edge source="database" target="web site">
  <data key="d3">retrieves information about user from</data>
</edge>
<edge source="database" target="data values">
  <data key="d3">require</data>
</edge>
<edge source="database" target="certain parts">
  <data key="d3">contain</data>
</edge>
<edge source="database" target="an instance">
  <data key="d3">has</data>
</edge>
<edge source="database" target="a schema">
  <data key="d3">has</data>
</edge>
<edge source="database" target="several schemas at the view level">
  <data key="d3">has</data>
</edge>
<edge source="database" target="schema">
  <data key="d3">has</data>
</edge>
<edge source="database" target="data model">
  <data key="d3">underlie the structure of</data>
</edge>
<edge source="database" target="E-R model">
  <data key="d3">uses</data>
</edge>
<edge source="database" target="fixed-format records">
  <data key="d3">is structured as</data>
</edge>
<edge source="database" target="people">
  <data key="d3">work with</data>
</edge>
<edge source="database" target="DBA">
  <data key="d3">backs up</data>
</edge>
<edge source="database" target="jobs running">
  <data key="d3">monitoring</data>
</edge>
<edge source="database" target="durability">
  <data key="d3">requires</data>
</edge>
<edge source="database" target="when a transaction terminates">
  <data key="d3">must be consistent</data>
</edge>
<edge source="database" target="state">
  <data key="d3">must be restored to</data>
</edge>
<edge source="database" target="state prior to failure">
  <data key="d3">restore to</data>
</edge>
<edge source="database" target="DML queries">
  <data key="d3">query</data>
</edge>
<edge source="database" target="database schema">
  <data key="d3">has an overall design called</data>
</edge>
<edge source="the collection of data, usually referred to as the database" target="information">
  <data key="d3">content</data>
</edge>
<edge source="information" target="telecommunication">
  <data key="d3">stores</data>
</edge>
<edge source="information" target="finance">
  <data key="d3">stores</data>
</edge>
<edge source="information" target="human resources">
  <data key="d3">stores</data>
</edge>
<edge source="information" target="into databases">
  <data key="d3">is inserted</data>
</edge>
<edge source="information" target="from databases">
  <data key="d3">is deleted</data>
</edge>
<edge source="information" target="database system">
  <data key="d3">stores</data>
</edge>
<edge source="information" target="disks">
  <data key="d3">stored on</data>
</edge>
<edge source="information" target="mechanisms">
  <data key="d3">must provide for</data>
</edge>
<edge source="the primary goal of a dbms" target="provide way to store and retrieve database information">
  <data key="d3">goal</data>
</edge>
<edge source="database systems" target="managing large bodies of information">
  <data key="d3">topic</data>
</edge>
<edge source="database systems" target="principles">
  <data key="d3">introduce</data>
</edge>
<edge source="database systems" target="difﬁculties">
  <data key="d3">prompted the development of</data>
</edge>
<edge source="database systems" target="several schemas">
  <data key="d3">have</data>
</edge>
<edge source="database systems" target="constraints">
  <data key="d3">check</data>
</edge>
<edge source="database systems" target="with databases many times every day">
  <data key="d3">are ubiquitous today and most people interact</data>
</edge>
<edge source="database systems" target="large bodies of information">
  <data key="d3">are designed to store</data>
</edge>
<edge source="database systems" target="dbms">
  <data key="d3">manages</data>
</edge>
<edge source="management of data" target="define structures for storage of information">
  <data key="d3">function</data>
</edge>
<edge source="providing mechanisms for the manipulation of information" target="manipulate information">
  <data key="d3">function</data>
</edge>
<edge source="the database system must ensure the safety of the information stored" target="ensure safety of information">
  <data key="d3">responsibility</data>
</edge>
<edge source="the system must avoid possible anomalous results" target="avoid anomalous results">
  <data key="d3">requirement</data>
</edge>
<edge source="computer scientists have developed a large body of concepts and techniques for managing data" target="develop concepts and techniques">
  <data key="d3">achievement</data>
</edge>
<edge source="these concepts and technique form the focus of this book" target="managing data">
  <data key="d3">topic</data>
</edge>
<edge source="this chapter briefly introduces the principles of database systems" target="introduce principles of database systems">
  <data key="d3">purpose</data>
</edge>
<edge source="computer scientists" target="concepts and techniques">
  <data key="d3">developed</data>
</edge>
<edge source="concepts and techniques" target="focus of this book">
  <data key="d3">form</data>
</edge>
<edge source="principles" target="database system concepts">
  <data key="d3">introduce</data>
</edge>
<edge source="database system applications" target="widely used">
  <data key="d3">are</data>
</edge>
<edge source="banking" target="databases for customer information, accounts, and loans">
  <data key="d3">uses</data>
</edge>
<edge source="airlines" target="databases in a geographically distributed manner">
  <data key="d3">use</data>
</edge>
<edge source="universities" target="databases for student information, course registrations, and grades">
  <data key="d3">use</data>
</edge>
<edge source="database system concepts" target="book">
  <data key="d3">contains</data>
</edge>
<edge source="database system concepts" target="Silberschatz-Korth-Sudarshan">
  <data key="d3">is referenced by</data>
</edge>
<edge source="credit card transactions" target="databases for purchases and generation of monthly statements">
  <data key="d3">uses</data>
</edge>
<edge source="telecommunication" target="databases for keeping records and generating monthly bills">
  <data key="d3">uses</data>
</edge>
<edge source="telecommunication" target="records">
  <data key="d3">uses</data>
</edge>
<edge source="telecommunication" target="generates">
  <data key="d3">uses</data>
</edge>
<edge source="telecommunication" target="balances">
  <data key="d3">maintains</data>
</edge>
<edge source="finance" target="databases for storing information about financial instruments">
  <data key="d3">uses</data>
</edge>
<edge source="records" target="special character">
  <data key="d3">delimit</data>
</edge>
<edge source="sales" target="customer">
  <data key="d3">stores</data>
</edge>
<edge source="sales" target="product">
  <data key="d3">stores</data>
</edge>
<edge source="sales" target="purchase">
  <data key="d3">stores</data>
</edge>
<edge source="customer" target="name">
  <data key="d3">has</data>
</edge>
<edge source="customer" target="street address">
  <data key="d3">has attribute</data>
</edge>
<edge source="customer" target="city">
  <data key="d3">has</data>
</edge>
<edge source="customer" target="id">
  <data key="d3">has</data>
</edge>
<edge source="customer" target="customer - id">
  <data key="d3">is identified by</data>
</edge>
<edge source="customer" target="social - security number">
  <data key="d3">uses as identifier</data>
</edge>
<edge source="customer" target="account">
  <data key="d3">must belong to only one</data>
</edge>
<edge source="customer" target="street">
  <data key="d3">has</data>
</edge>
<edge source="customer" target="id 192 - 83 - 7465">
  <data key="d3">has</data>
</edge>
<edge source="customer" target="johnson">
  <data key="d3">is named</data>
</edge>
<edge source="customer" target="12 alma st, palo alto">
  <data key="d3">lives at</data>
</edge>
<edge source="customer" target="a - 201">
  <data key="d3">shares account</data>
</edge>
<edge source="customer" target="Silberschatz-Korth-Sudarshan">
  <data key="d3">mentions</data>
</edge>
<edge source="customer" target="entity set">
  <data key="d3">corresponds to</data>
</edge>
<edge source="customer" target="customer-id">
  <data key="d3">has</data>
</edge>
<edge source="customer" target="customer-name">
  <data key="d3">has</data>
</edge>
<edge source="customer" target="table">
  <data key="d3">contains</data>
</edge>
<edge source="manufacturing" target="supply chain">
  <data key="d3">manages</data>
</edge>
<edge source="manufacturing" target="production">
  <data key="d3">tracks</data>
</edge>
<edge source="manufacturing" target="inventories">
  <data key="d3">tracks</data>
</edge>
<edge source="manufacturing" target="orders">
  <data key="d3">tracks</data>
</edge>
<edge source="human resources" target="paychecks">
  <data key="d3">generates</data>
</edge>
<edge source="databases" target="part">
  <data key="d3">form</data>
</edge>
<edge source="databases" target="bank tellers">
  <data key="d3">use</data>
</edge>
<edge source="databases" target="over time">
  <data key="d3">change</data>
</edge>
<edge source="automated teller machines" target="users interact with databases">
  <data key="d3">let</data>
</edge>
<edge source="phone interfaces" target="deal directly with databases">
  <data key="d3">allow users to</data>
</edge>
<edge source="caller" target="a number">
  <data key="d3">dial</data>
</edge>
<edge source="caller" target="phone keys">
  <data key="d3">press</data>
</edge>
<edge source="caller" target="or select alternative options">
  <data key="d3">enter information</data>
</edge>
<edge source="internet revolution" target="direct user access to databases">
  <data key="d3">increase</data>
</edge>
<edge source="organizations" target="phone interfaces to databases into web interfaces">
  <data key="d3">convert</data>
</edge>
<edge source="organizations" target="services and information online">
  <data key="d3">make available</data>
</edge>
<edge source="user" target="order stored in database">
  <data key="d3">enter order</data>
</edge>
<edge source="user" target="account balance">
  <data key="d3">wishes to find</data>
</edge>
<edge source="user" target="form">
  <data key="d3">accesses</data>
</edge>
<edge source="user" target="forms interface">
  <data key="d3">uses</data>
</edge>
<edge source="user" target="backup and recovery to the user">
  <data key="d3">leave</data>
</edge>
<edge source="bank website" target="bank's database system">
  <data key="d3">retrieve information from</data>
</edge>
<edge source="Bank" target="Database System">
  <data key="d3">uses</data>
</edge>
<edge source="Bank" target="Offer Checking Accounts">
  <data key="d3">decides</data>
</edge>
<edge source="Bank" target="Permanent Files">
  <data key="d3">creates</data>
</edge>
<edge source="Bank" target="New Application Programs">
  <data key="d3">writes</data>
</edge>
<edge source="Database System" target="authorization information">
  <data key="d3">consults</data>
</edge>
<edge source="Web Site" target="Database">
  <data key="d3">retrieves information from</data>
</edge>
<edge source="Web Site" target="User">
  <data key="d3">accesses</data>
</edge>
<edge source="Database" target="Savings Bank Enterprise">
  <data key="d3">keeps information about customers and savings accounts</data>
</edge>
<edge source="Database" target="Application programs">
  <data key="d3">interact with</data>
</edge>
<edge source="Database" target="Transactions">
  <data key="d3">complete successfully</data>
</edge>
<edge source="Database" target="Programs (debit account a, credit account b)">
  <data key="d3">execute one after the other</data>
</edge>
<edge source="Database" target="Programs">
  <data key="d3">not transform database</data>
</edge>
<edge source="Database" target="Transaction">
  <data key="d3">may not always complete execution</data>
</edge>
<edge source="Database" target="Failed transaction">
  <data key="d3">have no effect on database state</data>
</edge>
<edge source="Database" target="Failure Recovery">
  <data key="d3">be restored to previous state</data>
</edge>
<edge source="Oracle" target="none">
  <data key="d3">is among the largest software companies in the world</data>
</edge>
<edge source="Oracle" target="database system">
  <data key="d3">provide</data>
</edge>
<edge source="none" target="Microsoft">
  <data key="d3">has database systems as part of its product line</data>
</edge>
<edge source="none" target="IBM">
  <data key="d3">has database systems as part of its product line</data>
</edge>
<edge source="Microsoft" target="SQL Server">
  <data key="d3">provide</data>
</edge>
<edge source="IBM" target="SQL/DS">
  <data key="d3">led to</data>
</edge>
<edge source="IBM" target="DB2">
  <data key="d3">provide</data>
</edge>
<edge source="Enterprise" target="Operating System Files">
  <data key="d3">uses</data>
</edge>
<edge source="System" target="Information">
  <data key="d3">stores</data>
</edge>
<edge source="System" target="Files and Application Programs">
  <data key="d3">acquires</data>
</edge>
<edge source="System" target="Permanent Records">
  <data key="d3">stores</data>
</edge>
<edge source="System" target="Application Programs">
  <data key="d3">needs</data>
</edge>
<edge source="System" target="Records from Files">
  <data key="d3">extracts</data>
</edge>
<edge source="System" target="Records to Files">
  <data key="d3">adds</data>
</edge>
<edge source="Information" target="Several Places">
  <data key="d3">is duplicated</data>
</edge>
<edge source="Information" target="Main Memory">
  <data key="d3">cannot store</data>
</edge>
<edge source="Information" target="Disks">
  <data key="d3">store</data>
</edge>
<edge source="Application Programs" target="Files">
  <data key="d3">manipulate</data>
</edge>
<edge source="Application Programs" target="System Programmers">
  <data key="d3">write</data>
</edge>
<edge source="Files" target="Different Formats">
  <data key="d3">have</data>
</edge>
<edge source="Program" target="Account">
  <data key="d3">debits/credits</data>
</edge>
<edge source="Program" target="New Account">
  <data key="d3">adds</data>
</edge>
<edge source="Program" target="Account Balance">
  <data key="d3">finds</data>
</edge>
<edge source="Program" target="Monthly Statements">
  <data key="d3">generates</data>
</edge>
<edge source="Account" target="Customer Table">
  <data key="d3">stores</data>
</edge>
<edge source="Account" target="Customer">
  <data key="d3">is associated with</data>
</edge>
<edge source="Account" target="101">
  <data key="d3">has number</data>
</edge>
<edge source="Account" target="500">
  <data key="d3">has balance</data>
</edge>
<edge source="Account" target="215">
  <data key="d3">has number</data>
</edge>
<edge source="Account" target="700">
  <data key="d3">has balance</data>
</edge>
<edge source="Account" target="102">
  <data key="d3">has number</data>
</edge>
<edge source="Account" target="400">
  <data key="d3">has balance</data>
</edge>
<edge source="Account" target="305">
  <data key="d3">has number</data>
</edge>
<edge source="Account" target="350">
  <data key="d3">has balance</data>
</edge>
<edge source="Account" target="201">
  <data key="d3">has number</data>
</edge>
<edge source="Account" target="900">
  <data key="d3">has balance</data>
</edge>
<edge source="Account" target="217">
  <data key="d3">has number</data>
</edge>
<edge source="Account" target="750">
  <data key="d3">has balance</data>
</edge>
<edge source="Account" target="222">
  <data key="d3">has number</data>
</edge>
<edge source="Files and Application Programs" target="Programmers">
  <data key="d3">create</data>
</edge>
<edge source="Operating System" target="File Processing System">
  <data key="d3">supports</data>
</edge>
<edge source="Operating System" target="Typical File-Processing System">
  <data key="d3">supports</data>
</edge>
<edge source="Organizations" target="File-Processing Systems">
  <data key="d3">stored information in</data>
</edge>
<edge source="Programmers" target="logical level">
  <data key="d3">work at</data>
</edge>
<edge source="Programs" target="Several Programming Languages">
  <data key="d3">are written</data>
</edge>
<edge source="Programs" target="Transaction (transfer funds from account a to account b)">
  <data key="d3">be composed of</data>
</edge>
<edge source="Customer" target="Address and Telephone Number">
  <data key="d3">has</data>
</edge>
<edge source="Customer" target="Customer Table">
  <data key="d3">stores</data>
</edge>
<edge source="Customer" target="192-83-7465">
  <data key="d3">has id</data>
</edge>
<edge source="Customer" target="101">
  <data key="d3">has account</data>
</edge>
<edge source="Customer" target="201">
  <data key="d3">has account</data>
</edge>
<edge source="File" target="Savings-Account Records">
  <data key="d3">consists of</data>
</edge>
<edge source="File" target="Checking-Account Records">
  <data key="d3">consists of</data>
</edge>
<edge source="account records" target="checking">
  <data key="d3">consists of</data>
</edge>
<edge source="account records" target="higher storage and access cost">
  <data key="d3">leads to</data>
</edge>
<edge source="account records" target="data inconsistency">
  <data key="d3">may lead to</data>
</edge>
<edge source="data inconsistency" target="consistency constraints">
  <data key="d3">causes</data>
</edge>
<edge source="customer address" target="savings account records">
  <data key="d3">is reflected in</data>
</edge>
<edge source="customer address" target="elsewhere in the system">
  <data key="d3">may not be reflected in</data>
</edge>
<edge source="bank officer" target="names of all customers who live within a particular postal-code area">
  <data key="d3">needs to find out</data>
</edge>
<edge source="bank officer" target="data-processing department to generate such a list">
  <data key="d3">asks</data>
</edge>
<edge source="designers of the original system" target="this request">
  <data key="d3">did not anticipate</data>
</edge>
<edge source="data-processing department" target="an application program to generate the list of all customers">
  <data key="d3">has</data>
</edge>
<edge source="the mcgraw−hill companies" target="edition">
  <data key="d3">owns</data>
</edge>
<edge source="the mcgraw−hill companies" target="introduction text">
  <data key="d3">publishes</data>
</edge>
<edge source="the mcgraw−hill companies" target="introduction">
  <data key="d3">creates</data>
</edge>
<edge source="the mcgraw−hill companies" target="book">
  <data key="d3">publisher</data>
</edge>
<edge source="the mcgraw−hill companies" target="silberschatz−korth−sudarshan">
  <data key="d3">publishers</data>
</edge>
<edge source="the mcgraw−hill companies" target="copyright (©)">
  <data key="d3">owns</data>
</edge>
<edge source="introduction text" target="knowledge-silberschatz-korth-sudarshan: database system concepts, fourth edition">
  <data key="d3">contains</data>
</edge>
<edge source="a system programmer" target="application program">
  <data key="d3">writes</data>
</edge>
<edge source="an officer" target="list of all customers">
  <data key="d3">needs</data>
</edge>
<edge source="an officer" target="program to generate list">
  <data key="d3">requests</data>
</edge>
<edge source="an officer" target="list with account balance $10,000 or more">
  <data key="d3">needs</data>
</edge>
<edge source="conventional file-processing environments" target="retrieve data conveniently">
  <data key="d3">fail</data>
</edge>
<edge source="conventional file-processing environments" target="retrieving data efficiently">
  <data key="d3">fail</data>
</edge>
<edge source="data retrieval systems" target="general use">
  <data key="d3">require</data>
</edge>
<edge source="files" target="scattered data">
  <data key="d3">contain</data>
</edge>
<edge source="files" target="different formats">
  <data key="d3">exist</data>
</edge>
<edge source="files" target="tables">
  <data key="d3">store</data>
</edge>
<edge source="application programs" target="retrieving appropriate data">
  <data key="d3">struggle</data>
</edge>
<edge source="application programs" target="developers">
  <data key="d3">add code</data>
</edge>
<edge source="application programs" target="constraints">
  <data key="d3">enforce</data>
</edge>
<edge source="application programs" target="the system in an ad hoc manner">
  <data key="d3">added to</data>
</edge>
<edge source="application programs" target="Computer users">
  <data key="d3">see</data>
</edge>
<edge source="application programs" target="physical schema">
  <data key="d3">exhibit physical data independence</data>
</edge>
<edge source="application programs" target="application programmers">
  <data key="d3">write</data>
</edge>
<edge source="application programs" target="system">
  <data key="d3">submit</data>
</edge>
<edge source="application programs" target="storage manager subsystem">
  <data key="d3">interfaces</data>
</edge>
<edge source="data values" target="consistency constraints">
  <data key="d3">must satisfy</data>
</edge>
<edge source="consistency constraints" target="developers">
  <data key="d3">enforce</data>
</edge>
<edge source="consistency constraints" target="data consistency">
  <data key="d3">enforce</data>
</edge>
<edge source="bank account" target="balance">
  <data key="d3">has</data>
</edge>
<edge source="balance" target="tributes account">
  <data key="d3">has attribute</data>
</edge>
<edge source="balance" target="account">
  <data key="d3">has</data>
</edge>
<edge source="developers" target="abstraction">
  <data key="d3">hide complexity from users through</data>
</edge>
<edge source="constraints" target="data items">
  <data key="d3">involves</data>
</edge>
<edge source="data items" target="different files">
  <data key="d3">come from</data>
</edge>
<edge source="computer system" target="failure">
  <data key="d3">be subject to</data>
</edge>
<edge source="failure" target="inconsistent database state">
  <data key="d3">result in</data>
</edge>
<edge source="system failure" target="program execution">
  <data key="d3">occur during</data>
</edge>
<edge source="program" target="accounts">
  <data key="d3">transfer funds</data>
</edge>
<edge source="program" target="$50">
  <data key="d3">remove</data>
</edge>
<edge source="program" target="database consistency">
  <data key="d3">ensure</data>
</edge>
<edge source="program" target="variable declarations in a database schema">
  <data key="d3">corresponds to</data>
</edge>
<edge source="accounts" target="entity sets">
  <data key="d3">represents</data>
</edge>
<edge source="database consistency" target="both credit and debit">
  <data key="d3">require</data>
</edge>
<edge source="$50" target="account b">
  <data key="d3">be credited to</data>
</edge>
<edge source="funds transfer" target="in its entirety or not at all">
  <data key="d3">happen</data>
</edge>
<edge source="funds transfer" target="atomicity">
  <data key="d3">requiring</data>
</edge>
<edge source="funds transfer" target="consistency">
  <data key="d3">preserving</data>
</edge>
<edge source="funds transfer" target="durability">
  <data key="d3">persistence</data>
</edge>
<edge source="conventional file-processing system" target="atomicity">
  <data key="d3">ensure</data>
</edge>
<edge source="system" target="multiple users to update the data simultaneously">
  <data key="d3">allow</data>
</edge>
<edge source="system" target="some form of supervision">
  <data key="d3">maintain supervision</data>
</edge>
<edge source="system" target="data">
  <data key="d3">store</data>
</edge>
<edge source="system" target="many different application programs">
  <data key="d3">coordinate</data>
</edge>
<edge source="system" target="payroll personnel">
  <data key="d3">need</data>
</edge>
<edge source="system" target="the data">
  <data key="d3">hides certain details of how the data are stored and maintained</data>
</edge>
<edge source="system" target="users">
  <data key="d3">interact with</data>
</edge>
<edge source="system" target="naive users">
  <data key="d3">interact with</data>
</edge>
<edge source="system" target="system failures">
  <data key="d3">detect</data>
</edge>
<edge source="system" target="anomalous results">
  <data key="d3">must avoid</data>
</edge>
<edge source="system" target="details of how data are stored and maintained">
  <data key="d3">hides</data>
</edge>
<edge source="bank account a" target="$500">
  <data key="d3">contain</data>
</edge>
<edge source="$500" target="programs">
  <data key="d3">read value</data>
</edge>
<edge source="$500" target="account">
  <data key="d3">has</data>
</edge>
<edge source="customers" target="account a">
  <data key="d3">withdraw funds</data>
</edge>
<edge source="customers" target="entity sets">
  <data key="d3">represents</data>
</edge>
<edge source="programs" target="old balance">
  <data key="d3">read</data>
</edge>
<edge source="programs" target="value by amount being withdrawn">
  <data key="d3">reduce</data>
</edge>
<edge source="programs" target="amount being withdrawn">
  <data key="d3">reduce by</data>
</edge>
<edge source="programs" target="result">
  <data key="d3">write back</data>
</edge>
<edge source="programs" target="each other">
  <data key="d3">run concurrently</data>
</edge>
<edge source="pro - grams" target="withdrawal">
  <data key="d3">execute on behalf of</data>
</edge>
<edge source="each other" target="Client and Server Machines">
  <data key="d3">interact with</data>
</edge>
<edge source="data" target="files and a set of programs that allow users to access and modify these files">
  <data key="d3">is a collection of interrelated</data>
</edge>
<edge source="data" target="the system">
  <data key="d3">must be retrieved efﬁciently by</data>
</edge>
<edge source="data" target="table">
  <data key="d3">shows details of</data>
</edge>
<edge source="data" target="disk storage and main memory">
  <data key="d3">moved between</data>
</edge>
<edge source="data" target="disk storage">
  <data key="d3">moved from</data>
</edge>
<edge source="data" target="main memory">
  <data key="d3">moved to</data>
</edge>
<edge source="data" target="query processor">
  <data key="d3">helps simplify and facilitate access</data>
</edge>
<edge source="data" target="Storage manager">
  <data key="d3">store</data>
</edge>
<edge source="data" target="punched card decks">
  <data key="d3">could be input from</data>
</edge>
<edge source="data" target="printers">
  <data key="d3">could be output to</data>
</edge>
<edge source="data" target="data processing programs">
  <data key="d3">process</data>
</edge>
<edge source="data" target="tapes and card decks">
  <data key="d3">be read and merged</data>
</edge>
<edge source="data" target="disks">
  <data key="d3">allow direct access to</data>
</edge>
<edge source="data" target="the">
  <data key="d3">are to be shared among several users</data>
</edge>
<edge source="data" target="metadata">
  <data key="d3">describes</data>
</edge>
<edge source="security problems" target="database system">
  <data key="d3">exist</data>
</edge>
<edge source="database system" target="users">
  <data key="d3">access data</data>
</edge>
<edge source="database system" target="the data">
  <data key="d3">provide users with an abstract view of</data>
</edge>
<edge source="database system" target="lowest-level storage details from database programmers">
  <data key="d3">hides</data>
</edge>
<edge source="database system" target="statements">
  <data key="d3">uses</data>
</edge>
<edge source="database system" target="to figure out efficient means of accessing data">
  <data key="d3">has</data>
</edge>
<edge source="database system" target="failure recovery">
  <data key="d3">perform</data>
</edge>
<edge source="database system" target="data between disk and main memory">
  <data key="d3">minimizes the need to move</data>
</edge>
<edge source="database system" target="updates and queries">
  <data key="d3">translates</data>
</edge>
<edge source="database system" target="application architectures">
  <data key="d3">connect</data>
</edge>
<edge source="database system" target="server machines">
  <data key="d3">run</data>
</edge>
<edge source="database system" target="user application server">
  <data key="d3">had</data>
</edge>
<edge source="database system" target="people to use in retrieving and storing information">
  <data key="d3">provide an environment for</data>
</edge>
<edge source="database system" target="in the face of system crashes or attempts at unauthorized access">
  <data key="d3">must provide for the safety of the information stored</data>
</edge>
<edge source="database system" target="safety of information stored">
  <data key="d3">must provide for</data>
</edge>
<edge source="database system" target="abstract view of data">
  <data key="d3">must provide users with</data>
</edge>
<edge source="database system" target="Informix">
  <data key="d3">provide</data>
</edge>
<edge source="database system" target="Sybase">
  <data key="d3">provide</data>
</edge>
<edge source="users" target="language">
  <data key="d3">enables</data>
</edge>
<edge source="users" target="performance degradation">
  <data key="d3">submitting tasks</data>
</edge>
<edge source="payroll personnel" target="information about various bank employees">
  <data key="d3">need</data>
</edge>
<edge source="payroll personnel" target="information about customer accounts">
  <data key="d3">do not need access to</data>
</edge>
<edge source="security constraints" target="difﬁcult">
  <data key="d3">enforcing is</data>
</edge>
<edge source="we" target="concepts and algorithms that enable database systems to solve problems with ﬁle - processing systems">
  <data key="d3">shall see</data>
</edge>
<edge source="we" target="OLAP tools and data mining">
  <data key="d3">study</data>
</edge>
<edge source="this book" target="a typical data - processing application found in a corporation">
  <data key="d3">uses a bank enterprise as a running example of</data>
</edge>
<edge source="the system" target="many views for the same database">
  <data key="d3">may provide</data>
</edge>
<edge source="need for efﬁciency" target="complex data structures to represent data">
  <data key="d3">has led designers to use</data>
</edge>
<edge source="designers" target="complex data structures">
  <data key="d3">use</data>
</edge>
<edge source="physical level" target="complex low-level data structures">
  <data key="d3">describe</data>
</edge>
<edge source="logical level" target="what data are stored in the database">
  <data key="d3">describe</data>
</edge>
<edge source="logical level" target="relationships among those data">
  <data key="d3">describe</data>
</edge>
<edge source="logical level" target="Database administrators">
  <data key="d3">usually work at</data>
</edge>
<edge source="database administrators" target="logical level of abstraction">
  <data key="d3">use</data>
</edge>
<edge source="database administrators" target="information to keep in the database">
  <data key="d3">decide</data>
</edge>
<edge source="database administrators" target="concerned with">
  <data key="d3">may be</data>
</edge>
<edge source="silberschatz−korth−sudarshan" target="Database System Concepts">
  <data key="d3">wrote</data>
</edge>
<edge source="silberschatz−korth−sudarshan" target="chapter 7">
  <data key="d3">references</data>
</edge>
<edge source="silberschatz−korth−sudarshan" target="object - oriented data model">
  <data key="d3">refers to</data>
</edge>
<edge source="silberschatz−korth−sudarshan" target="e - r model">
  <data key="d3">refers to</data>
</edge>
<edge source="silberschatz−korth−sudarshan" target="1. introduction text 21">
  <data key="d3">authors</data>
</edge>
<edge source="silberschatz−korth−sudarshan" target="2001">
  <data key="d3">published on</data>
</edge>
<edge source="Database System Concepts" target="Major Advantages of a Database System">
  <data key="d3">describes</data>
</edge>
<edge source="users of the database system" target="part of the database">
  <data key="d3">need</data>
</edge>
<edge source="the view level of abstraction" target="to simplify their interaction with the system">
  <data key="d3">exists</data>
</edge>
<edge source="text" target="record type">
  <data key="d3">mentions</data>
</edge>
<edge source="record type" target="block of storage locations">
  <data key="d3">can be described as</data>
</edge>
<edge source="record type" target="fixed number of fields or attributes">
  <data key="d3">defines</data>
</edge>
<edge source="record type" target="table">
  <data key="d3">contains</data>
</edge>
<edge source="record type" target="fixed number of fields">
  <data key="d3">defines</data>
</edge>
<edge source="Pascal-like language" target="customer record type">
  <data key="d3">has fields for</data>
</edge>
<edge source="Pascal-like language" target="physical level detail from programmers">
  <data key="d3">hides</data>
</edge>
<edge source="banking enterprise" target="several record types">
  <data key="d3">may have</data>
</edge>
<edge source="banking enterprise" target="account record type">
  <data key="d3">has</data>
</edge>
<edge source="banking enterprise" target="employee record type">
  <data key="d3">has</data>
</edge>
<edge source="The Mcgraw-Hill Companies" target="2001">
  <data key="d3">related to</data>
</edge>
<edge source="Compiler" target="detail from programmers">
  <data key="d3">hides</data>
</edge>
<edge source="Database system" target="storage details from database programmers">
  <data key="d3">hides</data>
</edge>
<edge source="Database system" target="Data dictionary">
  <data key="d3">consults</data>
</edge>
<edge source="Database system" target="System Failures">
  <data key="d3">perform failure recovery</data>
</edge>
<edge source="Database system" target="Application server">
  <data key="d3">communicates with</data>
</edge>
<edge source="Database administrators" target="physical organization of data">
  <data key="d3">are aware of</data>
</edge>
<edge source="Database users" target="views of the database">
  <data key="d3">see</data>
</edge>
<edge source="Views" target="security mechanism to prevent access">
  <data key="d3">provide</data>
</edge>
<edge source="Tellers in a bank" target="part of the database with information on customer accounts">
  <data key="d3">can only see</data>
</edge>
<edge source="tellers" target="customer accounts">
  <data key="d3">see</data>
</edge>
<edge source="employees" target="salaries">
  <data key="d3">have</data>
</edge>
<edge source="instance" target="the database at a particular moment">
  <data key="d3">represents</data>
</edge>
<edge source="schema" target="the database design">
  <data key="d3">describes</data>
</edge>
<edge source="schema" target="database design">
  <data key="d3">describes</data>
</edge>
<edge source="schema" target="logical schema">
  <data key="d3">is hidden beneath</data>
</edge>
<edge source="schema" target="without affecting application programs">
  <data key="d3">can be changed</data>
</edge>
<edge source="schema" target="set of deﬁnitions">
  <data key="d3">is speciﬁed by</data>
</edge>
<edge source="schema" target="data - deﬁnition language (ddl)">
  <data key="d3">is expressed using</data>
</edge>
<edge source="schema" target="database instance">
  <data key="d3">contains</data>
</edge>
<edge source="schema" target="physical schema and logical schema">
  <data key="d3">defines</data>
</edge>
<edge source="variables" target="particular values">
  <data key="d3">have</data>
</edge>
<edge source="values of variables" target="an instance of a database schema">
  <data key="d3">correspond to</data>
</edge>
<edge source="schemas" target="according to the levels of abstraction">
  <data key="d3">are partitioned</data>
</edge>
<edge source="schemas" target="languages">
  <data key="d3">describe</data>
</edge>
<edge source="physical schema" target="the database design at the physical level">
  <data key="d3">describes</data>
</edge>
<edge source="logical schema" target="the database design at the logical level">
  <data key="d3">describes</data>
</edge>
<edge source="database design" target="entity-relationship model">
  <data key="d3">is used in</data>
</edge>
<edge source="data model" target="data, data relationships, data semantics, and consistency constraints">
  <data key="d3">describe</data>
</edge>
<edge source="data model" target="entity - relationship model">
  <data key="d3">concept</data>
</edge>
<edge source="data model" target="relational data model">
  <data key="d3">is the most widely used</data>
</edge>
<edge source="data model" target="language">
  <data key="d3">has</data>
</edge>
<edge source="data model" target="underlying structure of database">
  <data key="d3">is based on</data>
</edge>
<edge source="data model" target="con - ceptual tools for describing data, data relationships, data semantics, and data constraints">
  <data key="d3">provides</data>
</edge>
<edge source="data models" target="silberschatz−korth−sudarshan : database system concepts, fourth edition">
  <data key="d3">are outlined in</data>
</edge>
<edge source="data models" target="chapter 2">
  <data key="d3">are explored in detail in</data>
</edge>
<edge source="data models" target="task of modeling data">
  <data key="d3">complicate</data>
</edge>
<edge source="data models" target="appendices a and b">
  <data key="d3">outline</data>
</edge>
<edge source="data models" target="physical data independence">
  <data key="d3">ensures</data>
</edge>
<edge source="book" target="company">
  <data key="d3">publishes</data>
</edge>
<edge source="book" target="research.bell-labs.com">
  <data key="d3">hosts</data>
</edge>
<edge source="entities" target="basic objects">
  <data key="d3">type of</data>
</edge>
<edge source="entities" target="relationship set">
  <data key="d3">can be associated via</data>
</edge>
<edge source="real world" target="perception">
  <data key="d3">context</data>
</edge>
<edge source="tributes account" target="number">
  <data key="d3">has attribute</data>
</edge>
<edge source="number" target="account">
  <data key="d3">has</data>
</edge>
<edge source="person" target="U.S. government">
  <data key="d3">is assigned a unique number by</data>
</edge>
<edge source="person" target="social - security number">
  <data key="d3">has attribute</data>
</edge>
<edge source="account" target="depositor">
  <data key="d3">is associated with</data>
</edge>
<edge source="account" target="table">
  <data key="d3">contains</data>
</edge>
<edge source="account" target="$900">
  <data key="d3">has</data>
</edge>
<edge source="account" target="customer whose customer - id is 192 - 83 - 7465">
  <data key="d3">belongs to</data>
</edge>
<edge source="account" target="customer whose customer - id is 019 - 28 - 3746">
  <data key="d3">belongs to</data>
</edge>
<edge source="account" target="entity set">
  <data key="d3">corresponds to</data>
</edge>
<edge source="account" target="account-number">
  <data key="d3">has</data>
</edge>
<edge source="entity sets" target="relationships">
  <data key="d3">have</data>
</edge>
<edge source="rectangle" target="entity set">
  <data key="d3">represents</data>
</edge>
<edge source="ellipse" target="attribute">
  <data key="d3">represents</data>
</edge>
<edge source="diamond" target="relationship">
  <data key="d3">represents</data>
</edge>
<edge source="line" target="attributes">
  <data key="d3">links</data>
</edge>
<edge source="depositor" target="customer and account">
  <data key="d3">relates</data>
</edge>
<edge source="depositor" target="relationship set">
  <data key="d3">corresponds to</data>
</edge>
<edge source="depositor" target="table">
  <data key="d3">links</data>
</edge>
<edge source="depositor" target="customer-id">
  <data key="d3">has</data>
</edge>
<edge source="depositor" target="account-number">
  <data key="d3">has</data>
</edge>
<edge source="E-R model" target="relational model">
  <data key="d3">is at a lower level of abstraction than</data>
</edge>
<edge source="E-R model" target="database designs">
  <data key="d3">carried out</data>
</edge>
<edge source="chapter 2" target="translation process">
  <data key="d3">describes the</data>
</edge>
<edge source="table" target="records of a particular type">
  <data key="d3">contains</data>
</edge>
<edge source="table" target="attributes of the record type">
  <data key="d3">corresponds to</data>
</edge>
<edge source="table" target="attributes of record type">
  <data key="d3">corresponds to</data>
</edge>
<edge source="figure 1.2" target="ER diagram">
  <data key="d3">presents a sample</data>
</edge>
<edge source="figure 1.3" target="relational database">
  <data key="d3">presents a sample</data>
</edge>
<edge source="record-based model" target="relational model">
  <data key="d3">is an example of</data>
</edge>
<edge source="relational model" target="low-level implementation details">
  <data key="d3">hides</data>
</edge>
<edge source="relational model" target="current database systems">
  <data key="d3">based on</data>
</edge>
<edge source="relational model" target="Codd">
  <data key="d3">define</data>
</edge>
<edge source="relational model" target="non-procedural ways of querying data">
  <data key="d3">deﬁne</data>
</edge>
<edge source="relational model" target="1980s">
  <data key="d3">has reigned</data>
</edge>
<edge source="relational model" target="codd">
  <data key="d3">introduced</data>
</edge>
<edge source="special character" target="different attributes of a record">
  <data key="d3">delimit</data>
</edge>
<edge source="special character" target="dml calls">
  <data key="d3">prefaces</data>
</edge>
<edge source="relational data model" target="network data model">
  <data key="d3">precede</data>
</edge>
<edge source="relational data model" target="hierarchical data model">
  <data key="d3">precede</data>
</edge>
<edge source="relational data model" target="data in databases">
  <data key="d3">is widely used to store</data>
</edge>
<edge source="chapters 3-7" target="relational model in detail">
  <data key="d3">cover</data>
</edge>
<edge source="translation process" target="Silberschatz-Korth-Sudarshan">
  <data key="d3">describes</data>
</edge>
<edge source="tables customer and account" target="entity sets same name">
  <data key="d3">correspond to</data>
</edge>
<edge source="table depositor" target="relationship set depositor">
  <data key="d3">corresponds to</data>
</edge>
<edge source="Silberschatz-Korth-Sudarshan" target="a collection of interrelated data">
  <data key="d3">consists of</data>
</edge>
<edge source="Silberschatz-Korth-Sudarshan" target="a collection of programs to access that data">
  <data key="d3">consists of</data>
</edge>
<edge source="Lindsay" target="Smith">
  <data key="d3">has account</data>
</edge>
<edge source="Smith" target="72 North St, Rye">
  <data key="d3">has address</data>
</edge>
<edge source="Customer Table" target="Depositor">
  <data key="d3">stores</data>
</edge>
<edge source="Depositor Table" target="Figure 1.3">
  <data key="d3">represents</data>
</edge>
<edge source="chapter 7" target="schema designs">
  <data key="d3">studies</data>
</edge>
<edge source="chapter 7" target="good schema designs">
  <data key="d3">examines</data>
</edge>
<edge source="chapter 7" target="bad schema designs">
  <data key="d3">examines</data>
</edge>
<edge source="object - oriented data model" target="e - r model">
  <data key="d3">extends</data>
</edge>
<edge source="object - oriented data model" target="encapsulation">
  <data key="d3">features</data>
</edge>
<edge source="object - oriented data model" target="methods ( functions )">
  <data key="d3">features</data>
</edge>
<edge source="object - oriented data model" target="object identity">
  <data key="d3">features</data>
</edge>
<edge source="object - oriented data model" target="chapter 8">
  <data key="d3">examines in</data>
</edge>
<edge source="object - relational data model" target="features of object - oriented data model and relational data model">
  <data key="d3">combines</data>
</edge>
<edge source="object - relational data model" target="chapter 9">
  <data key="d3">examines in</data>
</edge>
<edge source="semistructured data models" target="where individual data items of the same type may have different sets of attributes">
  <data key="d3">permit the speciﬁcation of data</data>
</edge>
<edge source="semistructured data models" target="specification of data">
  <data key="d3">permit</data>
</edge>
<edge source="data models mentioned earlier" target="same set of attributes">
  <data key="d3">have</data>
</edge>
<edge source="xml" target="semistructured data">
  <data key="d3">represent</data>
</edge>
<edge source="chapter 10" target="it">
  <data key="d3">covers</data>
</edge>
<edge source="database languages" target="data definition language">
  <data key="d3">provide</data>
</edge>
<edge source="database languages" target="data manipulation language">
  <data key="d3">provide</data>
</edge>
<edge source="sql language" target="single database language">
  <data key="d3">form part of</data>
</edge>
<edge source="sql language" target="query">
  <data key="d3">uses</data>
</edge>
<edge source="SQL language" target="Database language">
  <data key="d3">forms part of</data>
</edge>
<edge source="SQL language" target="Account table">
  <data key="d3">deﬁnes</data>
</edge>
<edge source="SQL language" target="name of customer">
  <data key="d3">finds</data>
</edge>
<edge source="Data definition language (DDL)" target="Database schema">
  <data key="d3">specifies</data>
</edge>
<edge source="DML" target="Deﬁnitions">
  <data key="d3">expresses</data>
</edge>
<edge source="DML" target="access or manipulate data">
  <data key="d3">enables users to</data>
</edge>
<edge source="Account table" target="DML statement">
  <data key="d3">creates</data>
</edge>
<edge source="DML statement" target="Data dictionary">
  <data key="d3">up-dates</data>
</edge>
<edge source="Data dictionary" target="Metadata">
  <data key="d3">contains</data>
</edge>
<edge source="Metadata" target="Schema of a table">
  <data key="d3">is an example of</data>
</edge>
<edge source="Metadata" target="Data Dictionary">
  <data key="d3">contains</data>
</edge>
<edge source="DDL" target="Storage structure and access methods">
  <data key="d3">specifies</data>
</edge>
<edge source="DDL statements" target="Implementation details">
  <data key="d3">define</data>
</edge>
<edge source="statements" target="implementation details">
  <data key="d3">define</data>
</edge>
<edge source="implementation details" target="hidden from users">
  <data key="d3">are</data>
</edge>
<edge source="balance on account" target="$ 100">
  <data key="d3">should not fall below</data>
</edge>
<edge source="ddl" target="facilities to specify constraints">
  <data key="d3">provides</data>
</edge>
<edge source="ddl" target="m">
  <data key="d3">compiles</data>
</edge>
<edge source="text 22" target="Introduction">
  <data key="d3">is part of</data>
</edge>
<edge source="Introduction" target="1.5">
  <data key="d3">has chapter</data>
</edge>
<edge source="Data - Manipulation Language" target="retrieval">
  <data key="d3">includes</data>
</edge>
<edge source="Data - Manipulation Language" target="insertion">
  <data key="d3">includes</data>
</edge>
<edge source="Data - Manipulation Language" target="deletion">
  <data key="d3">includes</data>
</edge>
<edge source="Data - Manipulation Language" target="modification">
  <data key="d3">includes</data>
</edge>
<edge source="language" target="ac - cess or manipulate data">
  <data key="d3">enables users to</data>
</edge>
<edge source="language" target="dml">
  <data key="d3">is a type of</data>
</edge>
<edge source="DMLs" target="user to specify data">
  <data key="d3">require</data>
</edge>
<edge source="DMLs" target="user to get data">
  <data key="d3">require</data>
</edge>
<edge source="declarative DMLs" target="nonprocedural DMLs">
  <data key="d3">are</data>
</edge>
<edge source="declarative DMLs" target="easier to learn and use">
  <data key="d3">are</data>
</edge>
<edge source="DML component" target="nonprocedural">
  <data key="d3">is</data>
</edge>
<edge source="query" target="information retrieval">
  <data key="d3">requests</data>
</edge>
<edge source="query" target="name of customer">
  <data key="d3">finds</data>
</edge>
<edge source="query" target="rows to retrieve and display">
  <data key="d3">specifies</data>
</edge>
<edge source="query" target="information from multiple tables">
  <data key="d3">involves</data>
</edge>
<edge source="query" target="balance of all accounts">
  <data key="d3">finds</data>
</edge>
<edge source="information retrieval" target="portion of DML">
  <data key="d3">involves</data>
</edge>
<edge source="portion of DML" target="called query language">
  <data key="d3">is</data>
</edge>
<edge source="query language" target="synonymous with data manipulation language">
  <data key="d3">is</data>
</edge>
<edge source="if the above query were run on the tables in figure 1.3" target="print out the balances of the two accounts">
  <data key="d3">would</data>
</edge>
<edge source="the system would" target="that the two accounts numbered a - 101 and a - 201 are owned by customer 192 - 83 - 7465">
  <data key="d3">find</data>
</edge>
<edge source="the system would" target="the balances of the two accounts, namely 500 and 900">
  <data key="d3">print</data>
</edge>
<edge source="there are" target="a number of database query languages in use">
  <data key="d3">exist</data>
</edge>
<edge source="we study" target="sql, in chapter 4">
  <data key="d3">study</data>
</edge>
<edge source="we also study" target="some other query languages in chapter 5">
  <data key="d3">study</data>
</edge>
<edge source="the levels of abstraction that we discussed in section 1.3" target="to deﬁning or structuring data">
  <data key="d3">apply</data>
</edge>
<edge source="the levels of abstraction that we discussed in section 1.3" target="to manipulating data">
  <data key="d3">apply</data>
</edge>
<edge source="at the physical level" target="deﬁne algorithms that allow efﬁcient access to data">
  <data key="d3">must</data>
</edge>
<edge source="at higher levels of abstraction" target="ease of use">
  <data key="d3">emphasize</data>
</edge>
<edge source="the goal is" target="to allow humans to interact efﬁciently with the system">
  <data key="d3">aim</data>
</edge>
<edge source="the query processor component of the database system" target="dml queries into sequences">
  <data key="d3">translates</data>
</edge>
<edge source="Application programs" target="Host language">
  <data key="d3">write</data>
</edge>
<edge source="Application programs" target="Banking system">
  <data key="d3">have</data>
</edge>
<edge source="Application programs" target="query tools">
  <data key="d3">use</data>
</edge>
<edge source="DML queries" target="Sequences of actions at physical level">
  <data key="d3">translate into</data>
</edge>
<edge source="DML queries" target="Query processor component">
  <data key="d3">translates</data>
</edge>
<edge source="Host language" target="DML statements">
  <data key="d3">need to be executed from</data>
</edge>
<edge source="Application program interface" target="Send DML and DDL statements">
  <data key="d3">be used to</data>
</edge>
<edge source="ODBC standard" target="C language">
  <data key="d3">provide features for</data>
</edge>
<edge source="JDBC standard" target="Java language">
  <data key="d3">provide corresponding features for</data>
</edge>
<edge source="microsoft" target="(odbc)">
  <data key="d3">defines</data>
</edge>
<edge source="(odbc)" target="application program interface standard">
  <data key="d3">standardizes</data>
</edge>
<edge source="java" target="jdbc">
  <data key="d3">provides</data>
</edge>
<edge source="jdbc" target="features">
  <data key="d3">provides</data>
</edge>
<edge source="features" target="small personal computers">
  <data key="d3">may not have</data>
</edge>
<edge source="host language" target="dml calls">
  <data key="d3">extends</data>
</edge>
<edge source="precompiler" target="dml statements">
  <data key="d3">converts</data>
</edge>
<edge source="dml statements" target="query processor">
  <data key="d3">processes</data>
</edge>
<edge source="dml statements" target="compiler">
  <data key="d3">translates</data>
</edge>
<edge source="people" target="database users or database administrators">
  <data key="d3">categorize into</data>
</edge>
<edge source="user interfaces" target="different types of database-system users">
  <data key="d3">designed for</data>
</edge>
<edge source="naive users" target="forms interface">
  <data key="d3">use</data>
</edge>
<edge source="naive users" target="reports generated from the database">
  <data key="d3">may read</data>
</edge>
<edge source="bank teller" target="transfer program">
  <data key="d3">invokes</data>
</edge>
<edge source="transfer program" target="amount of money">
  <data key="d3">asks for</data>
</edge>
<edge source="transfer program" target="account from which the money is to be transferred">
  <data key="d3">asks for</data>
</edge>
<edge source="transfer program" target="account to which the money is to be transferred">
  <data key="d3">asks for</data>
</edge>
<edge source="account balance" target="web server">
  <data key="d3">passes</data>
</edge>
<edge source="application programmers" target="application">
  <data key="d3">write</data>
</edge>
<edge source="application programmers" target="many tools to develop user interfaces">
  <data key="d3">choose</data>
</edge>
<edge source="application programmers" target="forms and reports without writing a program">
  <data key="d3">construct</data>
</edge>
<edge source="rad tools" target="an application programmer to construct forms and reports">
  <data key="d3">enable</data>
</edge>
<edge source="special programming languages" target="imperative control structures with data manipulation language statements">
  <data key="d3">combine</data>
</edge>
<edge source="special programming languages" target="features to facilitate the generation of forms and display of data on the screen">
  <data key="d3">include</data>
</edge>
<edge source="major commercial database systems" target="fourth-generation language">
  <data key="d3">include</data>
</edge>
<edge source="sophisticated users" target="the system without writing programs">
  <data key="d3">interact with</data>
</edge>
<edge source="sophisticated users" target="database query language">
  <data key="d3">form their requests in</data>
</edge>
<edge source="sophisticated users" target="query processor">
  <data key="d3">submit queries to</data>
</edge>
<edge source="query processor" target="instructions that the storage manager understands">
  <data key="d3">break down DML statements into</data>
</edge>
<edge source="analysts" target="the database">
  <data key="d3">submit queries to explore data in</data>
</edge>
<edge source="analysts" target="online analytical processing">
  <data key="d3">fall into this category</data>
</edge>
<edge source="analysts" target="queries">
  <data key="d3">submit</data>
</edge>
<edge source="queries" target="DML compiler and organizer">
  <data key="d3">compile</data>
</edge>
<edge source="queries" target="Query evaluation engine">
  <data key="d3">evaluate</data>
</edge>
<edge source="queries" target="storage manager subsystem">
  <data key="d3">interfaces</data>
</edge>
<edge source="OLAP tools" target="analysts' tasks">
  <data key="d3">simplify</data>
</edge>
<edge source="OLAP tools" target="analyst to select specific regions">
  <data key="d3">permits</data>
</edge>
<edge source="OLAP tools" target="analyst to look at data in more detail">
  <data key="d3">permits</data>
</edge>
<edge source="OLAP tools" target="analyst to look at data in less detail">
  <data key="d3">permits</data>
</edge>
<edge source="analyst" target="summaries of data">
  <data key="d3">views</data>
</edge>
<edge source="analyst" target="total sales by region">
  <data key="d3">sees</data>
</edge>
<edge source="analyst" target="total sales by product">
  <data key="d3">sees</data>
</edge>
<edge source="analyst" target="total sales by combination of region and product">
  <data key="d3">sees</data>
</edge>
<edge source="data mining tools" target="analysts find certain kinds of patterns">
  <data key="d3">help</data>
</edge>
<edge source="study" target="Olap Tools">
  <data key="d3">use</data>
</edge>
<edge source="study" target="Data Mining">
  <data key="d3">learn about</data>
</edge>
<edge source="specialized users" target="specialized database applications">
  <data key="d3">write</data>
</edge>
<edge source="specialized database applications" target="computer-aided design systems">
  <data key="d3">are</data>
</edge>
<edge source="database administrator" target="data and programs that access those data">
  <data key="d3">has central control over</data>
</edge>
<edge source="DBA" target="functions">
  <data key="d3">includes</data>
</edge>
<edge source="DBA" target="data definition statements">
  <data key="d3">executes</data>
</edge>
<edge source="DBA" target="storage structure and access method">
  <data key="d3">defines</data>
</edge>
<edge source="DBA" target="schema and physical organization">
  <data key="d3">makes changes</data>
</edge>
<edge source="DBA" target="authorization for data access">
  <data key="d3">grants</data>
</edge>
<edge source="DBA" target="routine maintenance activities">
  <data key="d3">carries out</data>
</edge>
<edge source="DBA" target="free disk space">
  <data key="d3">ensures</data>
</edge>
<edge source="DBA" target="disk space">
  <data key="d3">upgrades</data>
</edge>
<edge source="DBA" target="jobs running on the database">
  <data key="d3">monitors</data>
</edge>
<edge source="DBA" target="performance is not degraded">
  <data key="d3">ensures</data>
</edge>
<edge source="schema definition" target="functions of a DBA">
  <data key="d3">is part of</data>
</edge>
<edge source="functions of a DBA" target="storage structure and access-method definition">
  <data key="d3">is part of</data>
</edge>
<edge source="functions of a DBA" target="schema and physical-organization modification">
  <data key="d3">is part of</data>
</edge>
<edge source="Database Administrator" target="data base access">
  <data key="d3">regulates</data>
</edge>
<edge source="transactions" target="logical units of work">
  <data key="d3">forming</data>
</edge>
<edge source="transactions" target="database-consistency constraints">
  <data key="d3">do not violate</data>
</edge>
<edge source="transactions" target="database concurrently">
  <data key="d3">update</data>
</edge>
<edge source="transactions" target="Transaction manager">
  <data key="d3">manage</data>
</edge>
<edge source="transaction" target="single logical function">
  <data key="d3">performs</data>
</edge>
<edge source="transaction" target="during execution">
  <data key="d3">may allow temporary inconsistency</data>
</edge>
<edge source="each transaction" target="unit of both atomicity and consistency">
  <data key="d3">is</data>
</edge>
<edge source="programmer" target="various transactions">
  <data key="d3">defines properly</data>
</edge>
<edge source="transaction to transfer funds" target="two separate programs">
  <data key="d3">is composed of</data>
</edge>
<edge source="Transactions" target="Data-base system">
  <data key="d3">ensure atomicity and durability</data>
</edge>
<edge source="Transactions" target="Database Administrator (dba)">
  <data key="d3">manages</data>
</edge>
<edge source="Transaction-management component" target="Atomicity and Durability">
  <data key="d3">be responsible for</data>
</edge>
<edge source="concurrency control manager" target="interaction among transactions">
  <data key="d3">control</data>
</edge>
<edge source="manager" target="consistency of database">
  <data key="d3">ensure</data>
</edge>
<edge source="systems" target="one user to access database at a time">
  <data key="d3">allow</data>
</edge>
<edge source="systems" target="backup and recovery">
  <data key="d3">do not offer</data>
</edge>
<edge source="data manager" target="especially main memory">
  <data key="d3">require fewer physical resources</data>
</edge>
<edge source="approach" target="but inadequate for medium-to-large-scale enterprise">
  <data key="d3">adequate for small personal databases</data>
</edge>
<edge source="Database System Structure" target="Modules">
  <data key="d3">is divided into</data>
</edge>
<edge source="Modules" target="Responsibilities">
  <data key="d3">deal with</data>
</edge>
<edge source="Storage Manager" target="Databases">
  <data key="d3">is important for</data>
</edge>
<edge source="Storage Manager" target="data structures as part of physical system implementation">
  <data key="d3">implements several</data>
</edge>
<edge source="Databases" target="Large Amount of Storage Space">
  <data key="d3">require</data>
</edge>
<edge source="Query Processor Components" target="Functional Components">
  <data key="d3">are part of</data>
</edge>
<edge source="Corporate Databases" target="Gigabytes to Terabytes">
  <data key="d3">range in size from</data>
</edge>
<edge source="Gigabyte" target="1000 Megabytes">
  <data key="d3">equals</data>
</edge>
<edge source="Terabyte" target="1 Million Megabytes">
  <data key="d3">equals</data>
</edge>
<edge source="Main Memory" target="Disk Storage">
  <data key="d3">moves data between</data>
</edge>
<edge source="disks" target="network and hierarchical databases">
  <data key="d3">be created</data>
</edge>
<edge source="disk storage" target="file manager">
  <data key="d3">manages allocation of space on</data>
</edge>
<edge source="disk storage" target="buffer manager">
  <data key="d3">fetches data from</data>
</edge>
<edge source="main memory" target="buffer manager">
  <data key="d3">decides what data to cache in</data>
</edge>
<edge source="main memory" target="data sizes">
  <data key="d3">were much larger than</data>
</edge>
<edge source="high-level views" target="goal">
  <data key="d3">help achieve</data>
</edge>
<edge source="users of the system" target="physical details of implementation">
  <data key="d3">are not burdened with</data>
</edge>
<edge source="updates and queries" target="efficient sequence of operations">
  <data key="d3">translated into</data>
</edge>
<edge source="storage manager" target="low-level data stored in database and application programs">
  <data key="d3">provides interface between</data>
</edge>
<edge source="storage manager" target="file manager">
  <data key="d3">interacts with</data>
</edge>
<edge source="storage manager" target="low-level file-system commands">
  <data key="d3">translates</data>
</edge>
<edge source="storage manager" target="data in the database">
  <data key="d3">updates</data>
</edge>
<edge source="storage manager" target="data from the database">
  <data key="d3">retrieves</data>
</edge>
<edge source="storage manager" target="Naive users">
  <data key="d3">query</data>
</edge>
<edge source="file manager" target="disk">
  <data key="d3">manages data structures used to represent information stored on</data>
</edge>
<edge source="raw data" target="disk using file system">
  <data key="d3">stored on</data>
</edge>
<edge source="authorization and integrity manager" target="integrity constraints">
  <data key="d3">tests for satisfaction of</data>
</edge>
<edge source="authorization and integrity manager" target="users to access data">
  <data key="d3">checks authority of</data>
</edge>
<edge source="transaction manager" target="database remains in a consistent state">
  <data key="d3">ensures that</data>
</edge>
<edge source="transaction manager" target="concurrent transaction executions proceed without conflict">
  <data key="d3">ensures that</data>
</edge>
<edge source="disk" target="location">
  <data key="d3">be accessed in tens of milliseconds</data>
</edge>
<edge source="disk" target="data structures">
  <data key="d3">be stored on</data>
</edge>
<edge source="Buffer Manager" target="fetching data from disk storage">
  <data key="d3">is responsible for</data>
</edge>
<edge source="Buffer Manager" target="cache in main memory">
  <data key="d3">decides what to</data>
</edge>
<edge source="Buffer Manager" target="to handle large data sizes">
  <data key="d3">enables the database</data>
</edge>
<edge source="Data Files" target="database itself">
  <data key="d3">store the</data>
</edge>
<edge source="Data Dictionary" target="structure of the database and schema">
  <data key="d3">stores metadata about</data>
</edge>
<edge source="Indices" target="data items that hold particular values">
  <data key="d3">provide fast access to</data>
</edge>
<edge source="compiler" target="evaluation plan">
  <data key="d3">generates</data>
</edge>
<edge source="compiler" target="query optimization">
  <data key="d3">performs</data>
</edge>
<edge source="compiler" target="lowest cost evaluation plan">
  <data key="d3">picks</data>
</edge>
<edge source="query compiler" target="low-level instructions">
  <data key="d3">executes</data>
</edge>
<edge source="query compiler" target="query evaluation engine">
  <data key="d3">understands</data>
</edge>
<edge source="client machines" target="remote database users">
  <data key="d3">work</data>
</edge>
<edge source="client machines" target="database applications">
  <data key="d3">run at</data>
</edge>
<edge source="database applications" target="two or three parts">
  <data key="d3">partitioned</data>
</edge>
<edge source="database applications" target="front-end part and back end part">
  <data key="d3">are broken up into</data>
</edge>
<edge source="two-tier architecture" target="database system functionality">
  <data key="d3">invoke</data>
</edge>
<edge source="two-tier architecture" target="architecture">
  <data key="d3">was</data>
</edge>
<edge source="database system functionality" target="client machine">
  <data key="d3">invokes</data>
</edge>
<edge source="database system functionality" target="Client machine">
  <data key="d3">invokes</data>
</edge>
<edge source="client and server machines" target="through query language statements">
  <data key="d3">interact</data>
</edge>
<edge source="application program interface standards" target="interaction between client and server machines">
  <data key="d3">used for</data>
</edge>
<edge source="Client machine" target="ODBC and JDBC">
  <data key="d3">uses</data>
</edge>
<edge source="Client machine" target="Application server">
  <data key="d3">communicates with</data>
</edge>
<edge source="Application server" target="Business logic">
  <data key="d3">embeds</data>
</edge>
<edge source="Three-tier architecture" target="Large applications">
  <data key="d3">is more appropriate for</data>
</edge>
<edge source="Three-tier architecture" target="World wide web applications">
  <data key="d3">is more appropriate for</data>
</edge>
<edge source="Data processing" target="Computers">
  <data key="d3">drives the growth of</data>
</edge>
<edge source="Computers" target="Automation of data processing tasks">
  <data key="d3">predates</data>
</edge>
<edge source="Hollerith" target="punched cards">
  <data key="d3">invented</data>
</edge>
<edge source="Punched cards" target="record U.S. census data">
  <data key="d3">used to</data>
</edge>
<edge source="Mechanical systems" target="process data">
  <data key="d3">used to</data>
</edge>
<edge source="Application programmers" target="application interfaces">
  <data key="d3">use</data>
</edge>
<edge source="Application interfaces" target="application program object code">
  <data key="d3">provide</data>
</edge>
<edge source="Compiler and linker" target="object code">
  <data key="d3">translate</data>
</edge>
<edge source="Buffer manager" target="buffer">
  <data key="d3">manage</data>
</edge>
<edge source="File manager" target="file">
  <data key="d3">manage</data>
</edge>
<edge source="Authorization and integrity manager" target="integrity">
  <data key="d3">ensure</data>
</edge>
<edge source="DDL interpreter" target="schema changes">
  <data key="d3">interpret</data>
</edge>
<edge source="Administration tools" target="administration">
  <data key="d3">aid</data>
</edge>
<edge source="Sophisticated users (analysts)" target="write queries">
  <data key="d3">use</data>
</edge>
<edge source="1950s" target="magnetic tapes">
  <data key="d3">developed</data>
</edge>
<edge source="data processing tasks" target="payroll">
  <data key="d3">automated</data>
</edge>
<edge source="processing of data" target="reading from one or more tapes">
  <data key="d3">consisted</data>
</edge>
<edge source="three-tier architecture" target="architecture">
  <data key="d3">was</data>
</edge>
<edge source="salary raises" target="entering on punched cards">
  <data key="d3">were processed by</data>
</edge>
<edge source="salary raises" target="a tape containing the master salary details">
  <data key="d3">were read in synchro-nization with</data>
</edge>
<edge source="salary raises" target="the salary read from the master tape">
  <data key="d3">would be added to</data>
</edge>
<edge source="salary" target="master tape">
  <data key="d3">be added to</data>
</edge>
<edge source="master tape" target="new master tape">
  <data key="d3">become</data>
</edge>
<edge source="tapes" target="data processing programs">
  <data key="d3">read only sequentially</data>
</edge>
<edge source="data processing programs" target="card decks">
  <data key="d3">read only sequentially</data>
</edge>
<edge source="1960s" target="widespread use of hard disks">
  <data key="d3">witness</data>
</edge>
<edge source="hard disks" target="data processing">
  <data key="d3">change the scenario for</data>
</edge>
<edge source="position on disk" target="accessing data">
  <data key="d3">be immaterial</data>
</edge>
<edge source="data structures" target="programmers">
  <data key="d3">construct and manipulate</data>
</edge>
<edge source="programmers" target="similarity">
  <data key="d3">be enticing indeed</data>
</edge>
<edge source="programmers" target="Relational Model">
  <data key="d3">was enticing indeed due to its simplicity and possibility of hiding implementation details</data>
</edge>
<edge source="Codd" target="the prestigious Association of Computing Machinery Turing Award">
  <data key="d3">won</data>
</edge>
<edge source="IBM Research" target="an efficient relational database system">
  <data key="d3">developed techniques for the construction of</data>
</edge>
<edge source="an efficient relational database system" target="System R">
  <data key="d3">developed techniques for the construction of</data>
</edge>
<edge source="1980s" target="due to performance disadvantages">
  <data key="d3">the relational model was not used in practice initially</data>
</edge>
<edge source="1980s" target="parallel and distributed databases">
  <data key="d3">saw much research on</data>
</edge>
<edge source="1980s" target="object-oriented databases">
  <data key="d3">also saw initial work on</data>
</edge>
<edge source="1980s" target="transaction processing applications">
  <data key="d3">was the mainstay of databases</data>
</edge>
<edge source="System R" target="Astrahan et al.">
  <data key="d3">provided an overview</data>
</edge>
<edge source="System R" target="Chamberlin et al.">
  <data key="d3">provided an overview</data>
</edge>
<edge source="Initial Commercial Relational Database Systems" target="the development of relational databases">
  <data key="d3">played a role in</data>
</edge>
<edge source="Initial commercial relational database systems (IBM DB2, Oracle, Ingres, and DEC RDB)" target="advancing techniques for efficient processing of declarative queries">
  <data key="d3">played a major role in</data>
</edge>
<edge source="Relational databases" target="Network and Hierarchical Database Systems">
  <data key="d3">became competitive with</data>
</edge>
<edge source="Programmers using relational databases" target="deal with many low-level implementation details">
  <data key="d3">were forced to</data>
</edge>
<edge source="Programmers using relational databases" target="code their queries in a procedural fashion">
  <data key="d3">had to</data>
</edge>
<edge source="Programmers using relational databases" target="keep efficiency in mind when designing their programs">
  <data key="d3">had to</data>
</edge>
<edge source="Relational database" target="low-level tasks">
  <data key="d3">carried out automatically</data>
</edge>
<edge source="The programmer" target="a logical level">
  <data key="d3">was left free to work at</data>
</edge>
<edge source="The Relational Model" target="among data models">
  <data key="d3">attained dominance</data>
</edge>
<edge source="The 1980s" target="Parallel and Distributed Databases">
  <data key="d3">saw much research on</data>
</edge>
<edge source="The 1980s" target="Object-Oriented Databases">
  <data key="d3">saw initial work on</data>
</edge>
<edge source="SQL Language" target="Decision">
  <data key="d3">was designed primarily for</data>
</edge>
<edge source="1990s" target="decision support applications">
  <data key="d3">the SQL language was designed for</data>
</edge>
<edge source="1990s" target="a major application area for databases">
  <data key="d3">decision support and querying re-emerged as</data>
</edge>
<edge source="1990s" target="large growths in usage">
  <data key="d3">tools for analyzing large amounts of data saw</data>
</edge>
<edge source="1990s" target="parallel database products">
  <data key="d3">many database vendors introduced</data>
</edge>
<edge source="1990s" target="object-relational support">
  <data key="d3">database vendors also began to add</data>
</edge>
<edge source="late 1990s" target="world wide web">
  <data key="d3">the major event was the explosive growth of</data>
</edge>
<edge source="late 1990s" target="very high transaction processing rates">
  <data key="d3">database systems now had to support</data>
</edge>
<edge source="late 1990s" target="high reliability and availability">
  <data key="d3">also had to support</data>
</edge>
<edge source="late 1990s" target="web interfaces to data">
  <data key="d3">had to support</data>
</edge>
<edge source="summary" target="a collection of interrelated data">
  <data key="d3">a database-management system (DBMS) consists of</data>
</edge>
<edge source="data management" target="and the provision of mechanisms for the manipulation of information">
  <data key="d3">involves both the definition of structures for the storage of information</data>
</edge>
<edge source="data management" target="file systems">
  <data key="d3">relate to</data>
</edge>
<edge source="entity-relationship (e-r) data model" target="data, relationships, and constraints">
  <data key="d3">provides a convenient graphical representation to view</data>
</edge>
<edge source="other data models" target="object-oriented model, object-relational model, and semistructured data models">
  <data key="d3">are</data>
</edge>
<edge source="database schema" target="data-definition language (ddl)">
  <data key="d3">is specified by a set of deﬁnitions that are expressed using</data>
</edge>
<edge source="dml" target="m">
  <data key="d3">executes</data>
</edge>
<edge source="storage manager subsystem" target="interface">
  <data key="d3">provides</data>
</edge>
<edge source="storage manager subsystem" target="low-level data">
  <data key="d3">interfaces</data>
</edge>
<edge source="two-tier architectures" target="database running at the back end">
  <data key="d3">communicate directly with</data>
</edge>
<edge source="three-tier architectures" target="application server and database server">
  <data key="d3">broken up into</data>
</edge>
<edge source="application server and database server" target="back end part">
  <data key="d3">is broken up into</data>
</edge>
<edge source="data views" target="data abstraction">
  <data key="d3">provide</data>
</edge>
<edge source="data abstraction" target="physical data">
  <data key="d3">hides</data>
</edge>
<edge source="data dictionary" target="metadata">
  <data key="d3">contains</data>
</edge>
<edge source="File-processing System" target="DBMS">
  <data key="d3">is different from</data>
</edge>
<edge source="Physical Schema" target="Logical Schema">
  <data key="d3">has independence from</data>
</edge>
<edge source="Application Program" target="Database Languages">
  <data key="d3">uses</data>
</edge>
<edge source="Procedural Programming Language" target="Non-Procedural Programming Language">
  <data key="d3">compares to</data>
</edge>
<edge source="Database Management System" target="Setting up a Database">
  <data key="d3">has responsibilities for</data>
</edge>
<edge source="Responsibilities of a Database Management System" target="Discharging Problems">
  <data key="d3">include</data>
</edge>
<edge source="Main Functions of a Database Administrator" target="Tasks and Responsibilities">
  <data key="d3">involve</data>
</edge>
<edge source="McGraw-Hill Companies" target="textbook coverage">
  <data key="d3">own</data>
</edge>
<edge source="Abiteboul et al." target="1995">
  <data key="d3">write</data>
</edge>
<edge source="1995" target="Date">
  <data key="d3">write</data>
</edge>
<edge source="Elmasri and Navathe" target="2000">
  <data key="d3">write</data>
</edge>
<edge source="2000" target="O'Neil and O'Neil">
  <data key="d3">write</data>
</edge>
<edge source="2000" target="Ramakrishnan and Gehrke">
  <data key="d3">write</data>
</edge>
<edge source="Ullman" target="1988">
  <data key="d3">write</data>
</edge>
<edge source="Ullman" target="[1988]">
  <data key="d3">co-authored</data>
</edge>
<edge source="Bernstein and Newcomer" target="1997">
  <data key="d3">write</data>
</edge>
<edge source="Bernstein and Newcomer" target="textbook coverage of transaction processing [1997]">
  <data key="d3">provided</data>
</edge>
<edge source="Gray and Reuter" target="1993">
  <data key="d3">write</data>
</edge>
<edge source="Gray and Reuter" target="textbook coverage of transaction processing [1993]">
  <data key="d3">provided</data>
</edge>
<edge source="Ramakrishnan" target="[2000]">
  <data key="d3">co-authored</data>
</edge>
<edge source="[2000]" target="Gehrke">
  <data key="d3">co-authored</data>
</edge>
<edge source="fry and sibley" target="evolution of dbmss and development of database technology">
  <data key="d3">offer discussions</data>
</edge>
<edge source="evolution of dbmss and development of database technology" target="sibley">
  <data key="d3">offer discussions</data>
</edge>
<edge source="MySQL" target="free/public domain database system">
  <data key="d3">provide</data>
</edge>
<edge source="free/public domain database system" target="PostgreSQL">
  <data key="d3">provide</data>
</edge>
<edge source="com" target="ql">
  <data key="d3">hosts</data>
</edge>
<edge source="org" target="postgressql">
  <data key="d3">hosts</data>
</edge>
<edge source="postgressql" target="www.postgressql.org">
  <data key="d3">hosts</data>
</edge>
<edge source="www.research.bell-labs.com" target="db-book">
  <data key="d3">hosts</data>
</edge>
<edge source="www.research.bell-labs.com" target="topic">
  <data key="d3">hosts</data>
</edge>
</graph></graphml>